// Package CircleCI provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package rest_client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/pkg/errors"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// ListContextsParams defines parameters for ListContexts.
type ListContextsParams struct {

	// The unique ID of the owner of the context. Specify either this or owner-slug.
	OwnerId *string `json:"owner-id,omitempty"`

	// A string that represents an organization. Specify either this or owner-id. Cannot be used for accounts.
	OwnerSlug *string `json:"owner-slug,omitempty"`

	// The type of the owner. Defaults to "organization". Accounts are only used as context owners in server.
	OwnerType *string `json:"owner-type,omitempty"`

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`
}

// CreateContextJSONBody defines parameters for CreateContext.
type CreateContextJSONBody struct {

	// The user defined name of the context.
	Name  string `json:"name"`
	Owner struct {

		// The unique ID of the owner of the context. Specify either this or slug.
		Id *string `json:"id,omitempty"`

		// A string that represents an organization. Specify either this or id. Cannot be used for accounts.
		Slug *string `json:"slug,omitempty"`

		// The type of the owner. Defaults to "organization". Accounts are only used as context owners in server.
		Type *string `json:"type,omitempty"`
	} `json:"owner"`
}

// AddEnvironmentVariableToContextJSONBody defines parameters for AddEnvironmentVariableToContext.
type AddEnvironmentVariableToContextJSONBody struct {

	// The value of the environment variable
	Value string `json:"value"`
}

// GetProjectWorkflowMetricsParams defines parameters for GetProjectWorkflowMetrics.
type GetProjectWorkflowMetricsParams struct {

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`

	// The name of a vcs branch.
	Branch *string `json:"branch,omitempty"`
}

// GetProjectWorkflowRunsParams defines parameters for GetProjectWorkflowRuns.
type GetProjectWorkflowRunsParams struct {

	// The name of a vcs branch.
	Branch *string `json:"branch,omitempty"`

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`

	// Include only executions that started at or after this date. This must be specified if an end-date is provided.
	StartDate *time.Time `json:"start-date,omitempty"`

	// Include only executions that started before this date. This date can be at most 90 days after the start-date.
	EndDate *time.Time `json:"end-date,omitempty"`
}

// GetProjectWorkflowJobMetricsParams defines parameters for GetProjectWorkflowJobMetrics.
type GetProjectWorkflowJobMetricsParams struct {

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`

	// The name of a vcs branch.
	Branch *string `json:"branch,omitempty"`
}

// GetProjectJobRunsParams defines parameters for GetProjectJobRuns.
type GetProjectJobRunsParams struct {

	// The name of a vcs branch.
	Branch *string `json:"branch,omitempty"`

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`

	// Include only executions that started at or after this date. This must be specified if an end-date is provided.
	StartDate *time.Time `json:"start-date,omitempty"`

	// Include only executions that started before this date. This date can be at most 90 days after the start-date.
	EndDate *time.Time `json:"end-date,omitempty"`
}

// ListPipelinesParams defines parameters for ListPipelines.
type ListPipelinesParams struct {

	// Org slug in the form `vcs-slug/org-name`
	OrgSlug *string `json:"org-slug,omitempty"`

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`

	// Only include entries created by your user.
	Mine *bool `json:"mine,omitempty"`
}

// ListWorkflowsByPipelineIdParams defines parameters for ListWorkflowsByPipelineId.
type ListWorkflowsByPipelineIdParams struct {

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`
}

// CreateCheckoutKeyJSONBody defines parameters for CreateCheckoutKey.
type CreateCheckoutKeyJSONBody struct {

	// The type of checkout key to create. This may be either `deploy-key` or `user-key`.
	Type string `json:"type"`
}

// CreateEnvVarJSONBody defines parameters for CreateEnvVar.
type CreateEnvVarJSONBody struct {

	// The name of the environment variable.
	Name string `json:"name"`

	// The value of the environment variable.
	Value string `json:"value"`
}

// ListPipelinesForProjectParams defines parameters for ListPipelinesForProject.
type ListPipelinesForProjectParams struct {

	// The name of a vcs branch.
	Branch *string `json:"branch,omitempty"`

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`
}

// TriggerPipelineJSONBody defines parameters for TriggerPipeline.
type TriggerPipelineJSONBody struct {

	// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
	Branch *string `json:"branch,omitempty"`

	// An object containing pipeline parameters and their values.
	Parameters *TriggerPipelineJSONBody_Parameters `json:"parameters,omitempty"`

	// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
	Tag *string `json:"tag,omitempty"`
}

// TriggerPipelineParams defines parameters for TriggerPipeline.
type TriggerPipelineParams struct {

	// The login or user-readable identifier for the pipeline's triggerer. Internal use only.
	XAttributionLogin *string `json:"x-attribution-login,omitempty"`

	// The id the integration uses to identify the pipeline's triggerer. Internal use only.
	XAttributionActorId *string `json:"x-attribution-actor-id,omitempty"`
}

// TriggerPipelineJSONBody_Parameters defines parameters for TriggerPipeline.
type TriggerPipelineJSONBody_Parameters struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ListMyPipelinesParams defines parameters for ListMyPipelines.
type ListMyPipelinesParams struct {

	// A token to retrieve the next page of results.
	PageToken *string `json:"page-token,omitempty"`
}

// RerunWorkflowJSONBody defines parameters for RerunWorkflow.
type RerunWorkflowJSONBody struct {

	// Whether to rerun the workflow from the failed job. Mutually exclusive with the jobs parameter.
	FromFailed *bool `json:"from_failed,omitempty"`

	// A list of job IDs to rerun.
	Jobs *[]string `json:"jobs,omitempty"`
}

// CreateContextRequestBody defines body for CreateContext for application/json ContentType.
type CreateContextJSONRequestBody CreateContextJSONBody

// AddEnvironmentVariableToContextRequestBody defines body for AddEnvironmentVariableToContext for application/json ContentType.
type AddEnvironmentVariableToContextJSONRequestBody AddEnvironmentVariableToContextJSONBody

// CreateCheckoutKeyRequestBody defines body for CreateCheckoutKey for application/json ContentType.
type CreateCheckoutKeyJSONRequestBody CreateCheckoutKeyJSONBody

// CreateEnvVarRequestBody defines body for CreateEnvVar for application/json ContentType.
type CreateEnvVarJSONRequestBody CreateEnvVarJSONBody

// TriggerPipelineRequestBody defines body for TriggerPipeline for application/json ContentType.
type TriggerPipelineJSONRequestBody TriggerPipelineJSONBody

// RerunWorkflowRequestBody defines body for RerunWorkflow for application/json ContentType.
type RerunWorkflowJSONRequestBody RerunWorkflowJSONBody

// Getter for additional properties for TriggerPipelineJSONBody_Parameters. Returns the specified
// element and whether it was found
func (a TriggerPipelineJSONBody_Parameters) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TriggerPipelineJSONBody_Parameters
func (a *TriggerPipelineJSONBody_Parameters) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TriggerPipelineJSONBody_Parameters to handle AdditionalProperties
func (a *TriggerPipelineJSONBody_Parameters) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TriggerPipelineJSONBody_Parameters to handle AdditionalProperties
func (a TriggerPipelineJSONBody_Parameters) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListContexts request
	ListContexts(ctx context.Context, params *ListContextsParams) (*http.Response, error)

	// CreateContext request  with any body
	CreateContextWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateContext(ctx context.Context, body CreateContextJSONRequestBody) (*http.Response, error)

	// DeleteContext request
	DeleteContext(ctx context.Context, contextId string) (*http.Response, error)

	// GetContext request
	GetContext(ctx context.Context, contextId string) (*http.Response, error)

	// ListEnvironmentVariablesFromContext request
	ListEnvironmentVariablesFromContext(ctx context.Context, contextId string) (*http.Response, error)

	// DeleteEnvironmentVariableFromContext request
	DeleteEnvironmentVariableFromContext(ctx context.Context, contextId string, envVarName string) (*http.Response, error)

	// AddEnvironmentVariableToContext request  with any body
	AddEnvironmentVariableToContextWithBody(ctx context.Context, contextId string, envVarName string, contentType string, body io.Reader) (*http.Response, error)

	AddEnvironmentVariableToContext(ctx context.Context, contextId string, envVarName string, body AddEnvironmentVariableToContextJSONRequestBody) (*http.Response, error)

	// GetProjectWorkflowMetrics request
	GetProjectWorkflowMetrics(ctx context.Context, projectSlug string, params *GetProjectWorkflowMetricsParams) (*http.Response, error)

	// GetProjectWorkflowRuns request
	GetProjectWorkflowRuns(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowRunsParams) (*http.Response, error)

	// GetProjectWorkflowJobMetrics request
	GetProjectWorkflowJobMetrics(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowJobMetricsParams) (*http.Response, error)

	// GetProjectJobRuns request
	GetProjectJobRuns(ctx context.Context, projectSlug string, workflowName string, jobName string, params *GetProjectJobRunsParams) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context) (*http.Response, error)

	// GetCollaborations request
	GetCollaborations(ctx context.Context) (*http.Response, error)

	// ListPipelines request
	ListPipelines(ctx context.Context, params *ListPipelinesParams) (*http.Response, error)

	// GetPipelineById request
	GetPipelineById(ctx context.Context, pipelineId string) (*http.Response, error)

	// GetPipelineConfigById request
	GetPipelineConfigById(ctx context.Context, pipelineId string) (*http.Response, error)

	// ListWorkflowsByPipelineId request
	ListWorkflowsByPipelineId(ctx context.Context, pipelineId string, params *ListWorkflowsByPipelineIdParams) (*http.Response, error)

	// GetProjectBySlug request
	GetProjectBySlug(ctx context.Context, projectSlug string) (*http.Response, error)

	// ListCheckoutKeys request
	ListCheckoutKeys(ctx context.Context, projectSlug string) (*http.Response, error)

	// CreateCheckoutKey request  with any body
	CreateCheckoutKeyWithBody(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*http.Response, error)

	CreateCheckoutKey(ctx context.Context, projectSlug string, body CreateCheckoutKeyJSONRequestBody) (*http.Response, error)

	// DeleteCheckoutKey request
	DeleteCheckoutKey(ctx context.Context, projectSlug string, fingerprint string) (*http.Response, error)

	// GetCheckoutKey request
	GetCheckoutKey(ctx context.Context, projectSlug string, fingerprint string) (*http.Response, error)

	// ListEnvVars request
	ListEnvVars(ctx context.Context, projectSlug string) (*http.Response, error)

	// CreateEnvVar request  with any body
	CreateEnvVarWithBody(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*http.Response, error)

	CreateEnvVar(ctx context.Context, projectSlug string, body CreateEnvVarJSONRequestBody) (*http.Response, error)

	// DeleteEnvVar request
	DeleteEnvVar(ctx context.Context, projectSlug string, name string) (*http.Response, error)

	// GetEnvVar request
	GetEnvVar(ctx context.Context, projectSlug string, name string) (*http.Response, error)

	// GetJobDetails request
	GetJobDetails(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error)

	// CancelJob request
	CancelJob(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error)

	// ListPipelinesForProject request
	ListPipelinesForProject(ctx context.Context, projectSlug string, params *ListPipelinesForProjectParams) (*http.Response, error)

	// TriggerPipeline request  with any body
	TriggerPipelineWithBody(ctx context.Context, projectSlug string, params *TriggerPipelineParams, contentType string, body io.Reader) (*http.Response, error)

	TriggerPipeline(ctx context.Context, projectSlug string, params *TriggerPipelineParams, body TriggerPipelineJSONRequestBody) (*http.Response, error)

	// ListMyPipelines request
	ListMyPipelines(ctx context.Context, projectSlug string, params *ListMyPipelinesParams) (*http.Response, error)

	// GetPipelineByNumber request
	GetPipelineByNumber(ctx context.Context, projectSlug string, pipelineNumber interface{}) (*http.Response, error)

	// GetJobArtifacts request
	GetJobArtifacts(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error)

	// GetTests request
	GetTests(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id string) (*http.Response, error)

	// GetWorkflowById request
	GetWorkflowById(ctx context.Context, id string) (*http.Response, error)

	// ApprovePendingApprovalJobById request
	ApprovePendingApprovalJobById(ctx context.Context, id string, approvalRequestId string) (*http.Response, error)

	// CancelWorkflow request
	CancelWorkflow(ctx context.Context, id string) (*http.Response, error)

	// ListWorkflowJobs request
	ListWorkflowJobs(ctx context.Context, id string) (*http.Response, error)

	// RerunWorkflow request  with any body
	RerunWorkflowWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	RerunWorkflow(ctx context.Context, id string, body RerunWorkflowJSONRequestBody) (*http.Response, error)
}

func (c *Client) ListContexts(ctx context.Context, params *ListContextsParams) (*http.Response, error) {
	req, err := NewListContextsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContextWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateContextRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContext(ctx context.Context, body CreateContextJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateContextRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContext(ctx context.Context, contextId string) (*http.Response, error) {
	req, err := NewDeleteContextRequest(c.Server, contextId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetContext(ctx context.Context, contextId string) (*http.Response, error) {
	req, err := NewGetContextRequest(c.Server, contextId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvironmentVariablesFromContext(ctx context.Context, contextId string) (*http.Response, error) {
	req, err := NewListEnvironmentVariablesFromContextRequest(c.Server, contextId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvironmentVariableFromContext(ctx context.Context, contextId string, envVarName string) (*http.Response, error) {
	req, err := NewDeleteEnvironmentVariableFromContextRequest(c.Server, contextId, envVarName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AddEnvironmentVariableToContextWithBody(ctx context.Context, contextId string, envVarName string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAddEnvironmentVariableToContextRequestWithBody(c.Server, contextId, envVarName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AddEnvironmentVariableToContext(ctx context.Context, contextId string, envVarName string, body AddEnvironmentVariableToContextJSONRequestBody) (*http.Response, error) {
	req, err := NewAddEnvironmentVariableToContextRequest(c.Server, contextId, envVarName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectWorkflowMetrics(ctx context.Context, projectSlug string, params *GetProjectWorkflowMetricsParams) (*http.Response, error) {
	req, err := NewGetProjectWorkflowMetricsRequest(c.Server, projectSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectWorkflowRuns(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowRunsParams) (*http.Response, error) {
	req, err := NewGetProjectWorkflowRunsRequest(c.Server, projectSlug, workflowName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectWorkflowJobMetrics(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowJobMetricsParams) (*http.Response, error) {
	req, err := NewGetProjectWorkflowJobMetricsRequest(c.Server, projectSlug, workflowName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectJobRuns(ctx context.Context, projectSlug string, workflowName string, jobName string, params *GetProjectJobRunsParams) (*http.Response, error) {
	req, err := NewGetProjectJobRunsRequest(c.Server, projectSlug, workflowName, jobName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollaborations(ctx context.Context) (*http.Response, error) {
	req, err := NewGetCollaborationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListPipelines(ctx context.Context, params *ListPipelinesParams) (*http.Response, error) {
	req, err := NewListPipelinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineById(ctx context.Context, pipelineId string) (*http.Response, error) {
	req, err := NewGetPipelineByIdRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineConfigById(ctx context.Context, pipelineId string) (*http.Response, error) {
	req, err := NewGetPipelineConfigByIdRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowsByPipelineId(ctx context.Context, pipelineId string, params *ListWorkflowsByPipelineIdParams) (*http.Response, error) {
	req, err := NewListWorkflowsByPipelineIdRequest(c.Server, pipelineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectBySlug(ctx context.Context, projectSlug string) (*http.Response, error) {
	req, err := NewGetProjectBySlugRequest(c.Server, projectSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListCheckoutKeys(ctx context.Context, projectSlug string) (*http.Response, error) {
	req, err := NewListCheckoutKeysRequest(c.Server, projectSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCheckoutKeyWithBody(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateCheckoutKeyRequestWithBody(c.Server, projectSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCheckoutKey(ctx context.Context, projectSlug string, body CreateCheckoutKeyJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateCheckoutKeyRequest(c.Server, projectSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCheckoutKey(ctx context.Context, projectSlug string, fingerprint string) (*http.Response, error) {
	req, err := NewDeleteCheckoutKeyRequest(c.Server, projectSlug, fingerprint)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCheckoutKey(ctx context.Context, projectSlug string, fingerprint string) (*http.Response, error) {
	req, err := NewGetCheckoutKeyRequest(c.Server, projectSlug, fingerprint)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnvVars(ctx context.Context, projectSlug string) (*http.Response, error) {
	req, err := NewListEnvVarsRequest(c.Server, projectSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvVarWithBody(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateEnvVarRequestWithBody(c.Server, projectSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvVar(ctx context.Context, projectSlug string, body CreateEnvVarJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateEnvVarRequest(c.Server, projectSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvVar(ctx context.Context, projectSlug string, name string) (*http.Response, error) {
	req, err := NewDeleteEnvVarRequest(c.Server, projectSlug, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvVar(ctx context.Context, projectSlug string, name string) (*http.Response, error) {
	req, err := NewGetEnvVarRequest(c.Server, projectSlug, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobDetails(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error) {
	req, err := NewGetJobDetailsRequest(c.Server, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CancelJob(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error) {
	req, err := NewCancelJobRequest(c.Server, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListPipelinesForProject(ctx context.Context, projectSlug string, params *ListPipelinesForProjectParams) (*http.Response, error) {
	req, err := NewListPipelinesForProjectRequest(c.Server, projectSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPipelineWithBody(ctx context.Context, projectSlug string, params *TriggerPipelineParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewTriggerPipelineRequestWithBody(c.Server, projectSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPipeline(ctx context.Context, projectSlug string, params *TriggerPipelineParams, body TriggerPipelineJSONRequestBody) (*http.Response, error) {
	req, err := NewTriggerPipelineRequest(c.Server, projectSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListMyPipelines(ctx context.Context, projectSlug string, params *ListMyPipelinesParams) (*http.Response, error) {
	req, err := NewListMyPipelinesRequest(c.Server, projectSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineByNumber(ctx context.Context, projectSlug string, pipelineNumber interface{}) (*http.Response, error) {
	req, err := NewGetPipelineByNumberRequest(c.Server, projectSlug, pipelineNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobArtifacts(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error) {
	req, err := NewGetJobArtifactsRequest(c.Server, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetTests(ctx context.Context, projectSlug string, jobNumber interface{}) (*http.Response, error) {
	req, err := NewGetTestsRequest(c.Server, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowById(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetWorkflowByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ApprovePendingApprovalJobById(ctx context.Context, id string, approvalRequestId string) (*http.Response, error) {
	req, err := NewApprovePendingApprovalJobByIdRequest(c.Server, id, approvalRequestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CancelWorkflow(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewCancelWorkflowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowJobs(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewListWorkflowJobsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RerunWorkflowWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewRerunWorkflowRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RerunWorkflow(ctx context.Context, id string, body RerunWorkflowJSONRequestBody) (*http.Response, error) {
	req, err := NewRerunWorkflowRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewListContextsRequest generates requests for ListContexts
func NewListContextsRequest(server string, params *ListContextsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/context")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.OwnerId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "owner-id", *params.OwnerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OwnerSlug != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "owner-slug", *params.OwnerSlug); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OwnerType != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "owner-type", *params.OwnerType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContextRequest calls the generic CreateContext builder with application/json body
func NewCreateContextRequest(server string, body CreateContextJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContextRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateContextRequestWithBody generates requests for CreateContext with any type of body
func NewCreateContextRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/context")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteContextRequest generates requests for DeleteContext
func NewDeleteContextRequest(server string, contextId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "context-id", contextId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/context/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContextRequest generates requests for GetContext
func NewGetContextRequest(server string, contextId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "context-id", contextId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/context/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEnvironmentVariablesFromContextRequest generates requests for ListEnvironmentVariablesFromContext
func NewListEnvironmentVariablesFromContextRequest(server string, contextId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "context-id", contextId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/context/%s/environment-variable", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEnvironmentVariableFromContextRequest generates requests for DeleteEnvironmentVariableFromContext
func NewDeleteEnvironmentVariableFromContextRequest(server string, contextId string, envVarName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "context-id", contextId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "env-var-name", envVarName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/context/%s/environment-variable/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddEnvironmentVariableToContextRequest calls the generic AddEnvironmentVariableToContext builder with application/json body
func NewAddEnvironmentVariableToContextRequest(server string, contextId string, envVarName string, body AddEnvironmentVariableToContextJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddEnvironmentVariableToContextRequestWithBody(server, contextId, envVarName, "application/json", bodyReader)
}

// NewAddEnvironmentVariableToContextRequestWithBody generates requests for AddEnvironmentVariableToContext with any type of body
func NewAddEnvironmentVariableToContextRequestWithBody(server string, contextId string, envVarName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "context-id", contextId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "env-var-name", envVarName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/context/%s/environment-variable/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetProjectWorkflowMetricsRequest generates requests for GetProjectWorkflowMetrics
func NewGetProjectWorkflowMetricsRequest(server string, projectSlug string, params *GetProjectWorkflowMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/insights/%s/workflows", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "branch", *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectWorkflowRunsRequest generates requests for GetProjectWorkflowRuns
func NewGetProjectWorkflowRunsRequest(server string, projectSlug string, workflowName string, params *GetProjectWorkflowRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workflow-name", workflowName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/insights/%s/workflows/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "branch", *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "start-date", *params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "end-date", *params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectWorkflowJobMetricsRequest generates requests for GetProjectWorkflowJobMetrics
func NewGetProjectWorkflowJobMetricsRequest(server string, projectSlug string, workflowName string, params *GetProjectWorkflowJobMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workflow-name", workflowName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/insights/%s/workflows/%s/jobs", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "branch", *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectJobRunsRequest generates requests for GetProjectJobRuns
func NewGetProjectJobRunsRequest(server string, projectSlug string, workflowName string, jobName string, params *GetProjectJobRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "workflow-name", workflowName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "job-name", jobName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/insights/%s/workflows/%s/jobs/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "branch", *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "start-date", *params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "end-date", *params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/me")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollaborationsRequest generates requests for GetCollaborations
func NewGetCollaborationsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/me/collaborations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPipelinesRequest generates requests for ListPipelines
func NewListPipelinesRequest(server string, params *ListPipelinesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/pipeline")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.OrgSlug != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "org-slug", *params.OrgSlug); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mine != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "mine", *params.Mine); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineByIdRequest generates requests for GetPipelineById
func NewGetPipelineByIdRequest(server string, pipelineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "pipeline-id", pipelineId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/pipeline/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineConfigByIdRequest generates requests for GetPipelineConfigById
func NewGetPipelineConfigByIdRequest(server string, pipelineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "pipeline-id", pipelineId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/pipeline/%s/config", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkflowsByPipelineIdRequest generates requests for ListWorkflowsByPipelineId
func NewListWorkflowsByPipelineIdRequest(server string, pipelineId string, params *ListWorkflowsByPipelineIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "pipeline-id", pipelineId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/pipeline/%s/workflow", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectBySlugRequest generates requests for GetProjectBySlug
func NewGetProjectBySlugRequest(server string, projectSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCheckoutKeysRequest generates requests for ListCheckoutKeys
func NewListCheckoutKeysRequest(server string, projectSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/checkout-key", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCheckoutKeyRequest calls the generic CreateCheckoutKey builder with application/json body
func NewCreateCheckoutKeyRequest(server string, projectSlug string, body CreateCheckoutKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCheckoutKeyRequestWithBody(server, projectSlug, "application/json", bodyReader)
}

// NewCreateCheckoutKeyRequestWithBody generates requests for CreateCheckoutKey with any type of body
func NewCreateCheckoutKeyRequestWithBody(server string, projectSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/checkout-key", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteCheckoutKeyRequest generates requests for DeleteCheckoutKey
func NewDeleteCheckoutKeyRequest(server string, projectSlug string, fingerprint string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "fingerprint", fingerprint)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/checkout-key/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCheckoutKeyRequest generates requests for GetCheckoutKey
func NewGetCheckoutKeyRequest(server string, projectSlug string, fingerprint string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "fingerprint", fingerprint)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/checkout-key/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEnvVarsRequest generates requests for ListEnvVars
func NewListEnvVarsRequest(server string, projectSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/envvar", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnvVarRequest calls the generic CreateEnvVar builder with application/json body
func NewCreateEnvVarRequest(server string, projectSlug string, body CreateEnvVarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvVarRequestWithBody(server, projectSlug, "application/json", bodyReader)
}

// NewCreateEnvVarRequestWithBody generates requests for CreateEnvVar with any type of body
func NewCreateEnvVarRequestWithBody(server string, projectSlug string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/envvar", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteEnvVarRequest generates requests for DeleteEnvVar
func NewDeleteEnvVarRequest(server string, projectSlug string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "name", name)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/envvar/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvVarRequest generates requests for GetEnvVar
func NewGetEnvVarRequest(server string, projectSlug string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "name", name)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/envvar/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobDetailsRequest generates requests for GetJobDetails
func NewGetJobDetailsRequest(server string, projectSlug string, jobNumber interface{}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "job-number", jobNumber)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/job/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelJobRequest generates requests for CancelJob
func NewCancelJobRequest(server string, projectSlug string, jobNumber interface{}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "job-number", jobNumber)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/job/%s/cancel", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPipelinesForProjectRequest generates requests for ListPipelinesForProject
func NewListPipelinesForProjectRequest(server string, projectSlug string, params *ListPipelinesForProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/pipeline", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "branch", *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerPipelineRequest calls the generic TriggerPipeline builder with application/json body
func NewTriggerPipelineRequest(server string, projectSlug string, params *TriggerPipelineParams, body TriggerPipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerPipelineRequestWithBody(server, projectSlug, params, "application/json", bodyReader)
}

// NewTriggerPipelineRequestWithBody generates requests for TriggerPipeline with any type of body
func NewTriggerPipelineRequestWithBody(server string, projectSlug string, params *TriggerPipelineParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/pipeline", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	if params.XAttributionLogin != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParam("simple", false, "x-attribution-login", *params.XAttributionLogin)
		if err != nil {
			return nil, err
		}

		req.Header.Add("x-attribution-login", headerParam0)
	}

	if params.XAttributionActorId != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParam("simple", false, "x-attribution-actor-id", *params.XAttributionActorId)
		if err != nil {
			return nil, err
		}

		req.Header.Add("x-attribution-actor-id", headerParam1)
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListMyPipelinesRequest generates requests for ListMyPipelines
func NewListMyPipelinesRequest(server string, projectSlug string, params *ListMyPipelinesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/pipeline/mine", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page-token", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineByNumberRequest generates requests for GetPipelineByNumber
func NewGetPipelineByNumberRequest(server string, projectSlug string, pipelineNumber interface{}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "pipeline-number", pipelineNumber)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/pipeline/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobArtifactsRequest generates requests for GetJobArtifacts
func NewGetJobArtifactsRequest(server string, projectSlug string, jobNumber interface{}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "job-number", jobNumber)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/%s/artifacts", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTestsRequest generates requests for GetTests
func NewGetTestsRequest(server string, projectSlug string, jobNumber interface{}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project-slug", projectSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "job-number", jobNumber)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/project/%s/%s/tests", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/user/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkflowByIdRequest generates requests for GetWorkflowById
func NewGetWorkflowByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/workflow/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApprovePendingApprovalJobByIdRequest generates requests for ApprovePendingApprovalJobById
func NewApprovePendingApprovalJobByIdRequest(server string, id string, approvalRequestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "approval_request_id", approvalRequestId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/workflow/%s/approve/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelWorkflowRequest generates requests for CancelWorkflow
func NewCancelWorkflowRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/workflow/%s/cancel", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkflowJobsRequest generates requests for ListWorkflowJobs
func NewListWorkflowJobsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/workflow/%s/job", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRerunWorkflowRequest calls the generic RerunWorkflow builder with application/json body
func NewRerunWorkflowRequest(server string, id string, body RerunWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRerunWorkflowRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRerunWorkflowRequestWithBody generates requests for RerunWorkflow with any type of body
func NewRerunWorkflowRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/workflow/%s/rerun", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListContexts request
	ListContextsWithResponse(ctx context.Context, params *ListContextsParams) (*ListContextsResponse, error)

	// CreateContext request  with any body
	CreateContextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateContextResponse, error)

	CreateContextWithResponse(ctx context.Context, body CreateContextJSONRequestBody) (*CreateContextResponse, error)

	// DeleteContext request
	DeleteContextWithResponse(ctx context.Context, contextId string) (*DeleteContextResponse, error)

	// GetContext request
	GetContextWithResponse(ctx context.Context, contextId string) (*GetContextResponse, error)

	// ListEnvironmentVariablesFromContext request
	ListEnvironmentVariablesFromContextWithResponse(ctx context.Context, contextId string) (*ListEnvironmentVariablesFromContextResponse, error)

	// DeleteEnvironmentVariableFromContext request
	DeleteEnvironmentVariableFromContextWithResponse(ctx context.Context, contextId string, envVarName string) (*DeleteEnvironmentVariableFromContextResponse, error)

	// AddEnvironmentVariableToContext request  with any body
	AddEnvironmentVariableToContextWithBodyWithResponse(ctx context.Context, contextId string, envVarName string, contentType string, body io.Reader) (*AddEnvironmentVariableToContextResponse, error)

	AddEnvironmentVariableToContextWithResponse(ctx context.Context, contextId string, envVarName string, body AddEnvironmentVariableToContextJSONRequestBody) (*AddEnvironmentVariableToContextResponse, error)

	// GetProjectWorkflowMetrics request
	GetProjectWorkflowMetricsWithResponse(ctx context.Context, projectSlug string, params *GetProjectWorkflowMetricsParams) (*GetProjectWorkflowMetricsResponse, error)

	// GetProjectWorkflowRuns request
	GetProjectWorkflowRunsWithResponse(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowRunsParams) (*GetProjectWorkflowRunsResponse, error)

	// GetProjectWorkflowJobMetrics request
	GetProjectWorkflowJobMetricsWithResponse(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowJobMetricsParams) (*GetProjectWorkflowJobMetricsResponse, error)

	// GetProjectJobRuns request
	GetProjectJobRunsWithResponse(ctx context.Context, projectSlug string, workflowName string, jobName string, params *GetProjectJobRunsParams) (*GetProjectJobRunsResponse, error)

	// GetCurrentUser request
	GetCurrentUserWithResponse(ctx context.Context) (*GetCurrentUserResponse, error)

	// GetCollaborations request
	GetCollaborationsWithResponse(ctx context.Context) (*GetCollaborationsResponse, error)

	// ListPipelines request
	ListPipelinesWithResponse(ctx context.Context, params *ListPipelinesParams) (*ListPipelinesResponse, error)

	// GetPipelineById request
	GetPipelineByIdWithResponse(ctx context.Context, pipelineId string) (*GetPipelineByIdResponse, error)

	// GetPipelineConfigById request
	GetPipelineConfigByIdWithResponse(ctx context.Context, pipelineId string) (*GetPipelineConfigByIdResponse, error)

	// ListWorkflowsByPipelineId request
	ListWorkflowsByPipelineIdWithResponse(ctx context.Context, pipelineId string, params *ListWorkflowsByPipelineIdParams) (*ListWorkflowsByPipelineIdResponse, error)

	// GetProjectBySlug request
	GetProjectBySlugWithResponse(ctx context.Context, projectSlug string) (*GetProjectBySlugResponse, error)

	// ListCheckoutKeys request
	ListCheckoutKeysWithResponse(ctx context.Context, projectSlug string) (*ListCheckoutKeysResponse, error)

	// CreateCheckoutKey request  with any body
	CreateCheckoutKeyWithBodyWithResponse(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*CreateCheckoutKeyResponse, error)

	CreateCheckoutKeyWithResponse(ctx context.Context, projectSlug string, body CreateCheckoutKeyJSONRequestBody) (*CreateCheckoutKeyResponse, error)

	// DeleteCheckoutKey request
	DeleteCheckoutKeyWithResponse(ctx context.Context, projectSlug string, fingerprint string) (*DeleteCheckoutKeyResponse, error)

	// GetCheckoutKey request
	GetCheckoutKeyWithResponse(ctx context.Context, projectSlug string, fingerprint string) (*GetCheckoutKeyResponse, error)

	// ListEnvVars request
	ListEnvVarsWithResponse(ctx context.Context, projectSlug string) (*ListEnvVarsResponse, error)

	// CreateEnvVar request  with any body
	CreateEnvVarWithBodyWithResponse(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*CreateEnvVarResponse, error)

	CreateEnvVarWithResponse(ctx context.Context, projectSlug string, body CreateEnvVarJSONRequestBody) (*CreateEnvVarResponse, error)

	// DeleteEnvVar request
	DeleteEnvVarWithResponse(ctx context.Context, projectSlug string, name string) (*DeleteEnvVarResponse, error)

	// GetEnvVar request
	GetEnvVarWithResponse(ctx context.Context, projectSlug string, name string) (*GetEnvVarResponse, error)

	// GetJobDetails request
	GetJobDetailsWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*GetJobDetailsResponse, error)

	// CancelJob request
	CancelJobWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*CancelJobResponse, error)

	// ListPipelinesForProject request
	ListPipelinesForProjectWithResponse(ctx context.Context, projectSlug string, params *ListPipelinesForProjectParams) (*ListPipelinesForProjectResponse, error)

	// TriggerPipeline request  with any body
	TriggerPipelineWithBodyWithResponse(ctx context.Context, projectSlug string, params *TriggerPipelineParams, contentType string, body io.Reader) (*TriggerPipelineResponse, error)

	TriggerPipelineWithResponse(ctx context.Context, projectSlug string, params *TriggerPipelineParams, body TriggerPipelineJSONRequestBody) (*TriggerPipelineResponse, error)

	// ListMyPipelines request
	ListMyPipelinesWithResponse(ctx context.Context, projectSlug string, params *ListMyPipelinesParams) (*ListMyPipelinesResponse, error)

	// GetPipelineByNumber request
	GetPipelineByNumberWithResponse(ctx context.Context, projectSlug string, pipelineNumber interface{}) (*GetPipelineByNumberResponse, error)

	// GetJobArtifacts request
	GetJobArtifactsWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*GetJobArtifactsResponse, error)

	// GetTests request
	GetTestsWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*GetTestsResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, id string) (*GetUserResponse, error)

	// GetWorkflowById request
	GetWorkflowByIdWithResponse(ctx context.Context, id string) (*GetWorkflowByIdResponse, error)

	// ApprovePendingApprovalJobById request
	ApprovePendingApprovalJobByIdWithResponse(ctx context.Context, id string, approvalRequestId string) (*ApprovePendingApprovalJobByIdResponse, error)

	// CancelWorkflow request
	CancelWorkflowWithResponse(ctx context.Context, id string) (*CancelWorkflowResponse, error)

	// ListWorkflowJobs request
	ListWorkflowJobsWithResponse(ctx context.Context, id string) (*ListWorkflowJobsResponse, error)

	// RerunWorkflow request  with any body
	RerunWorkflowWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*RerunWorkflowResponse, error)

	RerunWorkflowWithResponse(ctx context.Context, id string, body RerunWorkflowJSONRequestBody) (*RerunWorkflowResponse, error)
}

type ListContextsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The date and time the context was created.
			CreatedAt time.Time `json:"created_at"`

			// The unique ID of the context.
			Id string `json:"id"`

			// The user defined name of the context.
			Name string `json:"name"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListContextsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContextsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The date and time the context was created.
		CreatedAt time.Time `json:"created_at"`

		// The unique ID of the context.
		Id string `json:"id"`

		// The user defined name of the context.
		Name string `json:"name"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The date and time the context was created.
		CreatedAt time.Time `json:"created_at"`

		// The unique ID of the context.
		Id string `json:"id"`

		// The user defined name of the context.
		Name string `json:"name"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvironmentVariablesFromContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// ID of the context (UUID)
			ContextId string `json:"context_id"`

			// The date and time the environment variable was created.
			CreatedAt time.Time `json:"created_at"`

			// The name of the environment variable
			Variable string `json:"variable"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEnvironmentVariablesFromContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvironmentVariablesFromContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvironmentVariableFromContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteEnvironmentVariableFromContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvironmentVariableFromContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddEnvironmentVariableToContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// ID of the context (UUID)
		ContextId string `json:"context_id"`

		// The date and time the environment variable was created.
		CreatedAt time.Time `json:"created_at"`

		// The name of the environment variable
		Variable string `json:"variable"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddEnvironmentVariableToContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddEnvironmentVariableToContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectWorkflowMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Workflow summary metrics.
		Items []struct {

			// Metrics relating to a workflow's runs.
			Metrics struct {

				// Metrics relating to the duration of runs for a workflow.
				DurationMetrics struct {

					// The max duration, in seconds, among a group of runs.
					Max int64 `json:"max"`

					// The mean duration, in seconds, among a group of runs.
					Mean int64 `json:"mean"`

					// The median duration, in seconds, among a group of runs.
					Median int64 `json:"median"`

					// The minimum duration, in seconds, among a group of runs.
					Min int64 `json:"min"`

					// The 95th percentile duration, in seconds, among a group of runs.
					P95 int64 `json:"p95"`

					// The standard deviation, in seconds, among a group of runs.
					StandardDeviation float32 `json:"standard_deviation"`
				} `json:"duration_metrics"`

				// The number of failed runs.
				FailedRuns int64 `json:"failed_runs"`

				// The mean time to recovery (mean time between failures and their next success) in seconds.
				Mttr int64 `json:"mttr"`

				// The ratio of successful runs / total runs.
				SuccessRate float32 `json:"success_rate"`

				// The number of successful runs.
				SuccessfulRuns int64 `json:"successful_runs"`

				// The average number of workflow runs per day.
				Throughput float32 `json:"throughput"`

				// The total credits consumed by the workflow in the aggregation window.
				TotalCreditsUsed int64 `json:"total_credits_used"`

				// The total number of runs.
				TotalRuns int64 `json:"total_runs"`
			} `json:"metrics"`

			// The name of the workflow.
			Name string `json:"name"`

			// The end of the aggregation window for workflow metrics.
			WindowEnd time.Time `json:"window_end"`

			// The start of the aggregation window for workflow metrics.
			WindowStart time.Time `json:"window_start"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectWorkflowMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectWorkflowMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Recent workflow runs.
		Items []struct {

			// The date and time the workflow was created.
			CreatedAt time.Time `json:"created_at"`

			// The number of credits used during execution
			CreditsUsed int64 `json:"credits_used"`

			// The duration in seconds of a run.
			Duration int64 `json:"duration"`

			// The unique ID of the workflow.
			Id string `json:"id"`

			// Workflow status.
			Status string `json:"status"`

			// The date and time the workflow stopped.
			StoppedAt time.Time `json:"stopped_at"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectWorkflowJobMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Job summary metrics.
		Items []struct {

			// Metrics relating to a workflow job's runs.
			Metrics struct {

				// Metrics relating to the duration of runs for a workflow job.
				DurationMetrics struct {

					// The max duration, in seconds, among a group of runs.
					Max int64 `json:"max"`

					// The mean duration, in seconds, among a group of runs.
					Mean int64 `json:"mean"`

					// The median duration, in seconds, among a group of runs.
					Median int64 `json:"median"`

					// The minimum duration, in seconds, among a group of runs.
					Min int64 `json:"min"`

					// The 95th percentile duration, in seconds, among a group of runs.
					P95 int64 `json:"p95"`

					// The standard deviation, in seconds, among a group of runs.
					StandardDeviation float32 `json:"standard_deviation"`
				} `json:"duration_metrics"`

				// The number of failed runs.
				FailedRuns int64 `json:"failed_runs"`

				// The ratio of successful runs / total runs.
				SuccessRate float32 `json:"success_rate"`

				// The number of successful runs.
				SuccessfulRuns int64 `json:"successful_runs"`

				// The average number of job runs per day.
				Throughput float32 `json:"throughput"`

				// The total credits consumed by the job in the aggregation window.
				TotalCreditsUsed int64 `json:"total_credits_used"`

				// The total number of runs.
				TotalRuns int64 `json:"total_runs"`
			} `json:"metrics"`

			// The name of the job.
			Name string `json:"name"`

			// The end of the aggregation window for job metrics.
			WindowEnd time.Time `json:"window_end"`

			// The start of the aggregation window for job metrics.
			WindowStart time.Time `json:"window_start"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectWorkflowJobMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectWorkflowJobMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectJobRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Recent job runs.
		Items []struct {

			// The number of credits used during execution
			CreditsUsed int64 `json:"credits_used"`

			// The unique ID of the job.
			Id string `json:"id"`

			// The date and time the job started.
			StartedAt time.Time `json:"started_at"`

			// Job status.
			Status string `json:"status"`

			// The time when the job stopped.
			StoppedAt time.Time `json:"stopped_at"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectJobRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectJobRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The unique ID of the user.
		Id string `json:"id"`

		// The login information for the user on the VCS.
		Login string `json:"login"`

		// The name of the user.
		Name string `json:"name"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollaborationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// URL to the user's avatar on the VCS
		AvatarUrl string `json:"avatar_url"`

		// The name of the organization
		Name string `json:"name"`

		// The VCS provider
		VcsType string `json:"vcs-type"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCollaborationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollaborationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The date and time the pipeline was created.
			CreatedAt time.Time `json:"created_at"`

			// A sequence of errors that have occurred within the pipeline.
			Errors []struct {

				// A human-readable error message.
				Message string `json:"message"`

				// The type of error.
				Type string `json:"type"`
			} `json:"errors"`

			// The unique ID of the pipeline.
			Id string `json:"id"`

			// The number of the pipeline.
			Number int64 `json:"number"`

			// The project-slug for the pipeline.
			ProjectSlug string `json:"project_slug"`

			// The current state of the pipeline.
			State string `json:"state"`

			// A summary of the trigger.
			Trigger struct {

				// The user who triggered the Pipeline.
				Actor struct {

					// URL to the user's avatar on the VCS
					AvatarUrl string `json:"avatar_url"`

					// The login information for the user on the VCS.
					Login string `json:"login"`
				} `json:"actor"`

				// The date and time the trigger was received.
				ReceivedAt time.Time `json:"received_at"`

				// The type of trigger.
				Type string `json:"type"`
			} `json:"trigger"`

			// The date and time the pipeline was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// VCS information for the pipeline.
			Vcs *struct {

				// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Branch *string `json:"branch,omitempty"`

				// The latest commit in the pipeline.
				Commit *struct {

					// The body of the commit message.
					Body string `json:"body"`

					// The subject of the commit message.
					Subject string `json:"subject"`
				} `json:"commit,omitempty"`

				// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
				OriginRepositoryUrl string `json:"origin_repository_url"`

				// Name of the VCS provider (e.g. GitHub, Bitbucket).
				ProviderName string `json:"provider_name"`

				// The code revision the pipeline ran.
				Revision string `json:"revision"`

				// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Tag *string `json:"tag,omitempty"`

				// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
				TargetRepositoryUrl string `json:"target_repository_url"`
			} `json:"vcs,omitempty"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The date and time the pipeline was created.
		CreatedAt time.Time `json:"created_at"`

		// A sequence of errors that have occurred within the pipeline.
		Errors []struct {

			// A human-readable error message.
			Message string `json:"message"`

			// The type of error.
			Type string `json:"type"`
		} `json:"errors"`

		// The unique ID of the pipeline.
		Id string `json:"id"`

		// The number of the pipeline.
		Number int64 `json:"number"`

		// The project-slug for the pipeline.
		ProjectSlug string `json:"project_slug"`

		// The current state of the pipeline.
		State string `json:"state"`

		// A summary of the trigger.
		Trigger struct {

			// The user who triggered the Pipeline.
			Actor struct {

				// URL to the user's avatar on the VCS
				AvatarUrl string `json:"avatar_url"`

				// The login information for the user on the VCS.
				Login string `json:"login"`
			} `json:"actor"`

			// The date and time the trigger was received.
			ReceivedAt time.Time `json:"received_at"`

			// The type of trigger.
			Type string `json:"type"`
		} `json:"trigger"`

		// The date and time the pipeline was last updated.
		UpdatedAt *time.Time `json:"updated_at,omitempty"`

		// VCS information for the pipeline.
		Vcs *struct {

			// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
			Branch *string `json:"branch,omitempty"`

			// The latest commit in the pipeline.
			Commit *struct {

				// The body of the commit message.
				Body string `json:"body"`

				// The subject of the commit message.
				Subject string `json:"subject"`
			} `json:"commit,omitempty"`

			// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
			OriginRepositoryUrl string `json:"origin_repository_url"`

			// Name of the VCS provider (e.g. GitHub, Bitbucket).
			ProviderName string `json:"provider_name"`

			// The code revision the pipeline ran.
			Revision string `json:"revision"`

			// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
			Tag *string `json:"tag,omitempty"`

			// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
			TargetRepositoryUrl string `json:"target_repository_url"`
		} `json:"vcs,omitempty"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelineByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineConfigByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The compiled configuration for the pipeline, after all orb expansion has been performed. If there were errors processing the pipeline's configuration, then this field may be empty.
		Compiled string `json:"compiled"`

		// The source configuration for the pipeline, before any config compilation has been performed. If there is no config, then this field will be empty.
		Source string `json:"source"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelineConfigByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineConfigByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowsByPipelineIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// A list of workflows.
		Items []struct {
			CanceledBy *string `json:"canceled_by,omitempty"`

			// The date and time the workflow was created.
			CreatedAt time.Time `json:"created_at"`
			ErroredBy *string   `json:"errored_by,omitempty"`

			// The unique ID of the workflow.
			Id string `json:"id"`

			// The name of the workflow.
			Name string `json:"name"`

			// The ID of the pipeline this workflow belongs to.
			PipelineId string `json:"pipeline_id"`

			// The number of the pipeline this workflow belongs to.
			PipelineNumber int64 `json:"pipeline_number"`

			// The project-slug for the pipeline this workflow belongs to.
			ProjectSlug string `json:"project_slug"`
			StartedBy   string `json:"started_by"`

			// The current status of the workflow.
			Status string `json:"status"`

			// The date and time the workflow stopped.
			StoppedAt time.Time `json:"stopped_at"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkflowsByPipelineIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowsByPipelineIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectBySlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The name of the project
		Name string `json:"name"`

		// The name of the organization the project belongs to
		OrganizationName string `json:"organization_name"`

		// Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
		Slug string `json:"slug"`

		// Information about the VCS that hosts the project source code.
		VcsInfo struct {
			DefaultBranch string `json:"default_branch"`

			// The VCS provider
			Provider string `json:"provider"`

			// URL to the repository hosting the project's code
			VcsUrl string `json:"vcs_url"`
		} `json:"vcs_info"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectBySlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectBySlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCheckoutKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The date and time the checkout key was created.
			CreatedAt time.Time `json:"created-at"`

			// An SSH key fingerprint.
			Fingerprint string `json:"fingerprint"`

			// A boolean value that indicates if this key is preferred.
			Preferred bool `json:"preferred"`

			// A public SSH key.
			PublicKey string `json:"public-key"`

			// The type of checkout key. This may be either `deploy-key` or `github-user-key`.
			Type string `json:"type"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCheckoutKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCheckoutKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCheckoutKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {

		// The date and time the checkout key was created.
		CreatedAt time.Time `json:"created-at"`

		// An SSH key fingerprint.
		Fingerprint string `json:"fingerprint"`

		// A boolean value that indicates if this key is preferred.
		Preferred bool `json:"preferred"`

		// A public SSH key.
		PublicKey string `json:"public-key"`

		// The type of checkout key. This may be either `deploy-key` or `github-user-key`.
		Type string `json:"type"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateCheckoutKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCheckoutKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCheckoutKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteCheckoutKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCheckoutKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCheckoutKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The date and time the checkout key was created.
		CreatedAt time.Time `json:"created-at"`

		// An SSH key fingerprint.
		Fingerprint string `json:"fingerprint"`

		// A boolean value that indicates if this key is preferred.
		Preferred bool `json:"preferred"`

		// A public SSH key.
		PublicKey string `json:"public-key"`

		// The type of checkout key. This may be either `deploy-key` or `github-user-key`.
		Type string `json:"type"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCheckoutKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCheckoutKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnvVarsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The name of the environment variable.
			Name string `json:"name"`

			// The value of the environment variable.
			Value string `json:"value"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEnvVarsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnvVarsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvVarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {

		// The name of the environment variable.
		Name string `json:"name"`

		// The value of the environment variable.
		Value string `json:"value"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateEnvVarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvVarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvVarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteEnvVarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvVarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvVarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The name of the environment variable.
		Name string `json:"name"`

		// The value of the environment variable.
		Value string `json:"value"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEnvVarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvVarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// List of contexts used by the job.
		Contexts []struct {

			// The name of the context.
			Name string `json:"name"`
		} `json:"contexts"`

		// The time when the job was created.
		CreatedAt time.Time `json:"created_at"`

		// Duration of a job in milliseconds.
		Duration int64 `json:"duration"`

		// Information about executor used for a job.
		Executor struct {

			// Resource class name.
			ResourceClass string `json:"resource_class"`

			// Executor type.
			Type string `json:"type"`
		} `json:"executor"`

		// Info about the latest workflow the job was a part of.
		LatestWorkflow struct {

			// The unique ID of the workflow.
			Id string `json:"id"`

			// The name of the workflow.
			Name string `json:"name"`
		} `json:"latest_workflow"`

		// Messages from CircleCI execution platform.
		Messages []struct {

			// Information describing message.
			Message string `json:"message"`

			// Value describing the reason for message to be added to the job.
			Reason *string `json:"reason,omitempty"`

			// Message type.
			Type string `json:"type"`
		} `json:"messages"`

		// The name of the job.
		Name string `json:"name"`

		// The number of the job.
		Number int64 `json:"number"`

		// Information about an organization.
		Organization struct {

			// The name of the organization.
			Name string `json:"name"`
		} `json:"organization"`

		// Info about parallels runs and their status.
		ParallelRuns []struct {

			// Index of the parallel run.
			Index int64 `json:"index"`

			// Status of the parallel run.
			Status string `json:"status"`
		} `json:"parallel_runs"`

		// A number of parallel runs the job has.
		Parallelism int64 `json:"parallelism"`

		// Info about a pipeline the job is a part of.
		Pipeline struct {

			// The unique ID of the pipeline.
			Id string `json:"id"`
		} `json:"pipeline"`

		// Information about a project.
		Project struct {

			// URL to the repository hosting the project's code
			ExternalUrl string `json:"external_url"`

			// The name of the project
			Name string `json:"name"`

			// Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
			Slug string `json:"slug"`
		} `json:"project"`

		// The time when the job was placed in a queue.
		QueuedAt time.Time `json:"queued_at"`

		// The date and time the job started.
		StartedAt time.Time `json:"started_at"`

		// The current status of the job.
		Status interface{} `json:"status"`

		// The time when the job stopped.
		StoppedAt *time.Time `json:"stopped_at,omitempty"`

		// URL of the job in CircleCI Web UI.
		WebUrl string `json:"web_url"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJobDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPipelinesForProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The date and time the pipeline was created.
			CreatedAt time.Time `json:"created_at"`

			// A sequence of errors that have occurred within the pipeline.
			Errors []struct {

				// A human-readable error message.
				Message string `json:"message"`

				// The type of error.
				Type string `json:"type"`
			} `json:"errors"`

			// The unique ID of the pipeline.
			Id string `json:"id"`

			// The number of the pipeline.
			Number int64 `json:"number"`

			// The project-slug for the pipeline.
			ProjectSlug string `json:"project_slug"`

			// The current state of the pipeline.
			State string `json:"state"`

			// A summary of the trigger.
			Trigger struct {

				// The user who triggered the Pipeline.
				Actor struct {

					// URL to the user's avatar on the VCS
					AvatarUrl string `json:"avatar_url"`

					// The login information for the user on the VCS.
					Login string `json:"login"`
				} `json:"actor"`

				// The date and time the trigger was received.
				ReceivedAt time.Time `json:"received_at"`

				// The type of trigger.
				Type string `json:"type"`
			} `json:"trigger"`

			// The date and time the pipeline was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// VCS information for the pipeline.
			Vcs *struct {

				// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Branch *string `json:"branch,omitempty"`

				// The latest commit in the pipeline.
				Commit *struct {

					// The body of the commit message.
					Body string `json:"body"`

					// The subject of the commit message.
					Subject string `json:"subject"`
				} `json:"commit,omitempty"`

				// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
				OriginRepositoryUrl string `json:"origin_repository_url"`

				// Name of the VCS provider (e.g. GitHub, Bitbucket).
				ProviderName string `json:"provider_name"`

				// The code revision the pipeline ran.
				Revision string `json:"revision"`

				// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Tag *string `json:"tag,omitempty"`

				// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
				TargetRepositoryUrl string `json:"target_repository_url"`
			} `json:"vcs,omitempty"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPipelinesForProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPipelinesForProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {

		// The date and time the pipeline was created.
		CreatedAt time.Time `json:"created_at"`

		// The unique ID of the pipeline.
		Id string `json:"id"`

		// The number of the pipeline.
		Number int64 `json:"number"`

		// The current state of the pipeline.
		State string `json:"state"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TriggerPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMyPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The date and time the pipeline was created.
			CreatedAt time.Time `json:"created_at"`

			// A sequence of errors that have occurred within the pipeline.
			Errors []struct {

				// A human-readable error message.
				Message string `json:"message"`

				// The type of error.
				Type string `json:"type"`
			} `json:"errors"`

			// The unique ID of the pipeline.
			Id string `json:"id"`

			// The number of the pipeline.
			Number int64 `json:"number"`

			// The project-slug for the pipeline.
			ProjectSlug string `json:"project_slug"`

			// The current state of the pipeline.
			State string `json:"state"`

			// A summary of the trigger.
			Trigger struct {

				// The user who triggered the Pipeline.
				Actor struct {

					// URL to the user's avatar on the VCS
					AvatarUrl string `json:"avatar_url"`

					// The login information for the user on the VCS.
					Login string `json:"login"`
				} `json:"actor"`

				// The date and time the trigger was received.
				ReceivedAt time.Time `json:"received_at"`

				// The type of trigger.
				Type string `json:"type"`
			} `json:"trigger"`

			// The date and time the pipeline was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// VCS information for the pipeline.
			Vcs *struct {

				// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Branch *string `json:"branch,omitempty"`

				// The latest commit in the pipeline.
				Commit *struct {

					// The body of the commit message.
					Body string `json:"body"`

					// The subject of the commit message.
					Subject string `json:"subject"`
				} `json:"commit,omitempty"`

				// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
				OriginRepositoryUrl string `json:"origin_repository_url"`

				// Name of the VCS provider (e.g. GitHub, Bitbucket).
				ProviderName string `json:"provider_name"`

				// The code revision the pipeline ran.
				Revision string `json:"revision"`

				// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Tag *string `json:"tag,omitempty"`

				// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
				TargetRepositoryUrl string `json:"target_repository_url"`
			} `json:"vcs,omitempty"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMyPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMyPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineByNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The date and time the pipeline was created.
		CreatedAt time.Time `json:"created_at"`

		// A sequence of errors that have occurred within the pipeline.
		Errors []struct {

			// A human-readable error message.
			Message string `json:"message"`

			// The type of error.
			Type string `json:"type"`
		} `json:"errors"`

		// The unique ID of the pipeline.
		Id string `json:"id"`

		// The number of the pipeline.
		Number int64 `json:"number"`

		// The project-slug for the pipeline.
		ProjectSlug string `json:"project_slug"`

		// The current state of the pipeline.
		State string `json:"state"`

		// A summary of the trigger.
		Trigger struct {

			// The user who triggered the Pipeline.
			Actor struct {

				// URL to the user's avatar on the VCS
				AvatarUrl string `json:"avatar_url"`

				// The login information for the user on the VCS.
				Login string `json:"login"`
			} `json:"actor"`

			// The date and time the trigger was received.
			ReceivedAt time.Time `json:"received_at"`

			// The type of trigger.
			Type string `json:"type"`
		} `json:"trigger"`

		// The date and time the pipeline was last updated.
		UpdatedAt *time.Time `json:"updated_at,omitempty"`

		// VCS information for the pipeline.
		Vcs *struct {

			// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
			Branch *string `json:"branch,omitempty"`

			// The latest commit in the pipeline.
			Commit *struct {

				// The body of the commit message.
				Body string `json:"body"`

				// The subject of the commit message.
				Subject string `json:"subject"`
			} `json:"commit,omitempty"`

			// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
			OriginRepositoryUrl string `json:"origin_repository_url"`

			// Name of the VCS provider (e.g. GitHub, Bitbucket).
			ProviderName string `json:"provider_name"`

			// The code revision the pipeline ran.
			Revision string `json:"revision"`

			// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
			Tag *string `json:"tag,omitempty"`

			// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
			TargetRepositoryUrl string `json:"target_repository_url"`
		} `json:"vcs,omitempty"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPipelineByNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineByNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobArtifactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The index of the node that stored the artifact.
			NodeIndex int64 `json:"node_index"`

			// The artifact path.
			Path string `json:"path"`

			// The URL to download the artifact contents.
			Url string `json:"url"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJobArtifactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobArtifactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The programmatic location of the test.
			Classname string `json:"classname"`

			// The file in which the test is defined.
			File string `json:"file"`

			// The failure message associated with the test.
			Message string `json:"message"`

			// The name of the test.
			Name string `json:"name"`

			// Indication of whether the test succeeded.
			Result string `json:"result"`

			// The time it took to run the test in seconds
			RunTime float64 `json:"run_time"`

			// The program that generated the test results
			Source string `json:"source"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// The unique ID of the user.
		Id string `json:"id"`

		// The login information for the user on the VCS.
		Login string `json:"login"`

		// The name of the user.
		Name string `json:"name"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CanceledBy *string `json:"canceled_by,omitempty"`

		// The date and time the workflow was created.
		CreatedAt time.Time `json:"created_at"`
		ErroredBy *string   `json:"errored_by,omitempty"`

		// The unique ID of the workflow.
		Id string `json:"id"`

		// The name of the workflow.
		Name string `json:"name"`

		// The ID of the pipeline this workflow belongs to.
		PipelineId string `json:"pipeline_id"`

		// The number of the pipeline this workflow belongs to.
		PipelineNumber int64 `json:"pipeline_number"`

		// The project-slug for the pipeline this workflow belongs to.
		ProjectSlug string `json:"project_slug"`
		StartedBy   string `json:"started_by"`

		// The current status of the workflow.
		Status string `json:"status"`

		// The date and time the workflow stopped.
		StoppedAt time.Time `json:"stopped_at"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkflowByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApprovePendingApprovalJobByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ApprovePendingApprovalJobByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApprovePendingApprovalJobByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []struct {

			// The unique ID of the job.
			ApprovalRequestId *string `json:"approval_request_id,omitempty"`

			// The unique ID of the user.
			ApprovedBy *string `json:"approved_by,omitempty"`

			// The unique ID of the user.
			CanceledBy *string `json:"canceled_by,omitempty"`

			// A sequence of the unique job IDs for the jobs that this job depends upon in the workflow.
			Dependencies []string `json:"dependencies"`

			// The unique ID of the job.
			Id string `json:"id"`

			// The number of the job.
			JobNumber *int64 `json:"job_number,omitempty"`

			// The name of the job.
			Name string `json:"name"`

			// The project-slug for the job.
			ProjectSlug string `json:"project_slug"`

			// The date and time the job started.
			StartedAt time.Time `json:"started_at"`

			// The current status of the job.
			Status interface{} `json:"status"`

			// The time when the job stopped.
			StoppedAt *time.Time `json:"stopped_at,omitempty"`

			// The type of job.
			Type string `json:"type"`
		} `json:"items"`

		// A token to pass as a `page-token` query parameter to return the next page of results.
		NextPageToken string `json:"next_page_token"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkflowJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RerunWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {

		// A human-readable message
		Message string `json:"message"`
	}
	JSONDefault *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RerunWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RerunWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListContextsWithResponse request returning *ListContextsResponse
func (c *ClientWithResponses) ListContextsWithResponse(ctx context.Context, params *ListContextsParams) (*ListContextsResponse, error) {
	rsp, err := c.ListContexts(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListContextsResponse(rsp)
}

// CreateContextWithBodyWithResponse request with arbitrary body returning *CreateContextResponse
func (c *ClientWithResponses) CreateContextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateContextResponse, error) {
	rsp, err := c.CreateContextWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateContextResponse(rsp)
}

func (c *ClientWithResponses) CreateContextWithResponse(ctx context.Context, body CreateContextJSONRequestBody) (*CreateContextResponse, error) {
	rsp, err := c.CreateContext(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateContextResponse(rsp)
}

// DeleteContextWithResponse request returning *DeleteContextResponse
func (c *ClientWithResponses) DeleteContextWithResponse(ctx context.Context, contextId string) (*DeleteContextResponse, error) {
	rsp, err := c.DeleteContext(ctx, contextId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContextResponse(rsp)
}

// GetContextWithResponse request returning *GetContextResponse
func (c *ClientWithResponses) GetContextWithResponse(ctx context.Context, contextId string) (*GetContextResponse, error) {
	rsp, err := c.GetContext(ctx, contextId)
	if err != nil {
		return nil, err
	}
	return ParseGetContextResponse(rsp)
}

// ListEnvironmentVariablesFromContextWithResponse request returning *ListEnvironmentVariablesFromContextResponse
func (c *ClientWithResponses) ListEnvironmentVariablesFromContextWithResponse(ctx context.Context, contextId string) (*ListEnvironmentVariablesFromContextResponse, error) {
	rsp, err := c.ListEnvironmentVariablesFromContext(ctx, contextId)
	if err != nil {
		return nil, err
	}
	return ParseListEnvironmentVariablesFromContextResponse(rsp)
}

// DeleteEnvironmentVariableFromContextWithResponse request returning *DeleteEnvironmentVariableFromContextResponse
func (c *ClientWithResponses) DeleteEnvironmentVariableFromContextWithResponse(ctx context.Context, contextId string, envVarName string) (*DeleteEnvironmentVariableFromContextResponse, error) {
	rsp, err := c.DeleteEnvironmentVariableFromContext(ctx, contextId, envVarName)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvironmentVariableFromContextResponse(rsp)
}

// AddEnvironmentVariableToContextWithBodyWithResponse request with arbitrary body returning *AddEnvironmentVariableToContextResponse
func (c *ClientWithResponses) AddEnvironmentVariableToContextWithBodyWithResponse(ctx context.Context, contextId string, envVarName string, contentType string, body io.Reader) (*AddEnvironmentVariableToContextResponse, error) {
	rsp, err := c.AddEnvironmentVariableToContextWithBody(ctx, contextId, envVarName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAddEnvironmentVariableToContextResponse(rsp)
}

func (c *ClientWithResponses) AddEnvironmentVariableToContextWithResponse(ctx context.Context, contextId string, envVarName string, body AddEnvironmentVariableToContextJSONRequestBody) (*AddEnvironmentVariableToContextResponse, error) {
	rsp, err := c.AddEnvironmentVariableToContext(ctx, contextId, envVarName, body)
	if err != nil {
		return nil, err
	}
	return ParseAddEnvironmentVariableToContextResponse(rsp)
}

// GetProjectWorkflowMetricsWithResponse request returning *GetProjectWorkflowMetricsResponse
func (c *ClientWithResponses) GetProjectWorkflowMetricsWithResponse(ctx context.Context, projectSlug string, params *GetProjectWorkflowMetricsParams) (*GetProjectWorkflowMetricsResponse, error) {
	rsp, err := c.GetProjectWorkflowMetrics(ctx, projectSlug, params)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectWorkflowMetricsResponse(rsp)
}

// GetProjectWorkflowRunsWithResponse request returning *GetProjectWorkflowRunsResponse
func (c *ClientWithResponses) GetProjectWorkflowRunsWithResponse(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowRunsParams) (*GetProjectWorkflowRunsResponse, error) {
	rsp, err := c.GetProjectWorkflowRuns(ctx, projectSlug, workflowName, params)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectWorkflowRunsResponse(rsp)
}

// GetProjectWorkflowJobMetricsWithResponse request returning *GetProjectWorkflowJobMetricsResponse
func (c *ClientWithResponses) GetProjectWorkflowJobMetricsWithResponse(ctx context.Context, projectSlug string, workflowName string, params *GetProjectWorkflowJobMetricsParams) (*GetProjectWorkflowJobMetricsResponse, error) {
	rsp, err := c.GetProjectWorkflowJobMetrics(ctx, projectSlug, workflowName, params)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectWorkflowJobMetricsResponse(rsp)
}

// GetProjectJobRunsWithResponse request returning *GetProjectJobRunsResponse
func (c *ClientWithResponses) GetProjectJobRunsWithResponse(ctx context.Context, projectSlug string, workflowName string, jobName string, params *GetProjectJobRunsParams) (*GetProjectJobRunsResponse, error) {
	rsp, err := c.GetProjectJobRuns(ctx, projectSlug, workflowName, jobName, params)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectJobRunsResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// GetCollaborationsWithResponse request returning *GetCollaborationsResponse
func (c *ClientWithResponses) GetCollaborationsWithResponse(ctx context.Context) (*GetCollaborationsResponse, error) {
	rsp, err := c.GetCollaborations(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetCollaborationsResponse(rsp)
}

// ListPipelinesWithResponse request returning *ListPipelinesResponse
func (c *ClientWithResponses) ListPipelinesWithResponse(ctx context.Context, params *ListPipelinesParams) (*ListPipelinesResponse, error) {
	rsp, err := c.ListPipelines(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListPipelinesResponse(rsp)
}

// GetPipelineByIdWithResponse request returning *GetPipelineByIdResponse
func (c *ClientWithResponses) GetPipelineByIdWithResponse(ctx context.Context, pipelineId string) (*GetPipelineByIdResponse, error) {
	rsp, err := c.GetPipelineById(ctx, pipelineId)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineByIdResponse(rsp)
}

// GetPipelineConfigByIdWithResponse request returning *GetPipelineConfigByIdResponse
func (c *ClientWithResponses) GetPipelineConfigByIdWithResponse(ctx context.Context, pipelineId string) (*GetPipelineConfigByIdResponse, error) {
	rsp, err := c.GetPipelineConfigById(ctx, pipelineId)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineConfigByIdResponse(rsp)
}

// ListWorkflowsByPipelineIdWithResponse request returning *ListWorkflowsByPipelineIdResponse
func (c *ClientWithResponses) ListWorkflowsByPipelineIdWithResponse(ctx context.Context, pipelineId string, params *ListWorkflowsByPipelineIdParams) (*ListWorkflowsByPipelineIdResponse, error) {
	rsp, err := c.ListWorkflowsByPipelineId(ctx, pipelineId, params)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowsByPipelineIdResponse(rsp)
}

// GetProjectBySlugWithResponse request returning *GetProjectBySlugResponse
func (c *ClientWithResponses) GetProjectBySlugWithResponse(ctx context.Context, projectSlug string) (*GetProjectBySlugResponse, error) {
	rsp, err := c.GetProjectBySlug(ctx, projectSlug)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectBySlugResponse(rsp)
}

// ListCheckoutKeysWithResponse request returning *ListCheckoutKeysResponse
func (c *ClientWithResponses) ListCheckoutKeysWithResponse(ctx context.Context, projectSlug string) (*ListCheckoutKeysResponse, error) {
	rsp, err := c.ListCheckoutKeys(ctx, projectSlug)
	if err != nil {
		return nil, err
	}
	return ParseListCheckoutKeysResponse(rsp)
}

// CreateCheckoutKeyWithBodyWithResponse request with arbitrary body returning *CreateCheckoutKeyResponse
func (c *ClientWithResponses) CreateCheckoutKeyWithBodyWithResponse(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*CreateCheckoutKeyResponse, error) {
	rsp, err := c.CreateCheckoutKeyWithBody(ctx, projectSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateCheckoutKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateCheckoutKeyWithResponse(ctx context.Context, projectSlug string, body CreateCheckoutKeyJSONRequestBody) (*CreateCheckoutKeyResponse, error) {
	rsp, err := c.CreateCheckoutKey(ctx, projectSlug, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateCheckoutKeyResponse(rsp)
}

// DeleteCheckoutKeyWithResponse request returning *DeleteCheckoutKeyResponse
func (c *ClientWithResponses) DeleteCheckoutKeyWithResponse(ctx context.Context, projectSlug string, fingerprint string) (*DeleteCheckoutKeyResponse, error) {
	rsp, err := c.DeleteCheckoutKey(ctx, projectSlug, fingerprint)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCheckoutKeyResponse(rsp)
}

// GetCheckoutKeyWithResponse request returning *GetCheckoutKeyResponse
func (c *ClientWithResponses) GetCheckoutKeyWithResponse(ctx context.Context, projectSlug string, fingerprint string) (*GetCheckoutKeyResponse, error) {
	rsp, err := c.GetCheckoutKey(ctx, projectSlug, fingerprint)
	if err != nil {
		return nil, err
	}
	return ParseGetCheckoutKeyResponse(rsp)
}

// ListEnvVarsWithResponse request returning *ListEnvVarsResponse
func (c *ClientWithResponses) ListEnvVarsWithResponse(ctx context.Context, projectSlug string) (*ListEnvVarsResponse, error) {
	rsp, err := c.ListEnvVars(ctx, projectSlug)
	if err != nil {
		return nil, err
	}
	return ParseListEnvVarsResponse(rsp)
}

// CreateEnvVarWithBodyWithResponse request with arbitrary body returning *CreateEnvVarResponse
func (c *ClientWithResponses) CreateEnvVarWithBodyWithResponse(ctx context.Context, projectSlug string, contentType string, body io.Reader) (*CreateEnvVarResponse, error) {
	rsp, err := c.CreateEnvVarWithBody(ctx, projectSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvVarResponse(rsp)
}

func (c *ClientWithResponses) CreateEnvVarWithResponse(ctx context.Context, projectSlug string, body CreateEnvVarJSONRequestBody) (*CreateEnvVarResponse, error) {
	rsp, err := c.CreateEnvVar(ctx, projectSlug, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvVarResponse(rsp)
}

// DeleteEnvVarWithResponse request returning *DeleteEnvVarResponse
func (c *ClientWithResponses) DeleteEnvVarWithResponse(ctx context.Context, projectSlug string, name string) (*DeleteEnvVarResponse, error) {
	rsp, err := c.DeleteEnvVar(ctx, projectSlug, name)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvVarResponse(rsp)
}

// GetEnvVarWithResponse request returning *GetEnvVarResponse
func (c *ClientWithResponses) GetEnvVarWithResponse(ctx context.Context, projectSlug string, name string) (*GetEnvVarResponse, error) {
	rsp, err := c.GetEnvVar(ctx, projectSlug, name)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvVarResponse(rsp)
}

// GetJobDetailsWithResponse request returning *GetJobDetailsResponse
func (c *ClientWithResponses) GetJobDetailsWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*GetJobDetailsResponse, error) {
	rsp, err := c.GetJobDetails(ctx, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetJobDetailsResponse(rsp)
}

// CancelJobWithResponse request returning *CancelJobResponse
func (c *ClientWithResponses) CancelJobWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*CancelJobResponse, error) {
	rsp, err := c.CancelJob(ctx, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	return ParseCancelJobResponse(rsp)
}

// ListPipelinesForProjectWithResponse request returning *ListPipelinesForProjectResponse
func (c *ClientWithResponses) ListPipelinesForProjectWithResponse(ctx context.Context, projectSlug string, params *ListPipelinesForProjectParams) (*ListPipelinesForProjectResponse, error) {
	rsp, err := c.ListPipelinesForProject(ctx, projectSlug, params)
	if err != nil {
		return nil, err
	}
	return ParseListPipelinesForProjectResponse(rsp)
}

// TriggerPipelineWithBodyWithResponse request with arbitrary body returning *TriggerPipelineResponse
func (c *ClientWithResponses) TriggerPipelineWithBodyWithResponse(ctx context.Context, projectSlug string, params *TriggerPipelineParams, contentType string, body io.Reader) (*TriggerPipelineResponse, error) {
	rsp, err := c.TriggerPipelineWithBody(ctx, projectSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPipelineResponse(rsp)
}

func (c *ClientWithResponses) TriggerPipelineWithResponse(ctx context.Context, projectSlug string, params *TriggerPipelineParams, body TriggerPipelineJSONRequestBody) (*TriggerPipelineResponse, error) {
	rsp, err := c.TriggerPipeline(ctx, projectSlug, params, body)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPipelineResponse(rsp)
}

// ListMyPipelinesWithResponse request returning *ListMyPipelinesResponse
func (c *ClientWithResponses) ListMyPipelinesWithResponse(ctx context.Context, projectSlug string, params *ListMyPipelinesParams) (*ListMyPipelinesResponse, error) {
	rsp, err := c.ListMyPipelines(ctx, projectSlug, params)
	if err != nil {
		return nil, err
	}
	return ParseListMyPipelinesResponse(rsp)
}

// GetPipelineByNumberWithResponse request returning *GetPipelineByNumberResponse
func (c *ClientWithResponses) GetPipelineByNumberWithResponse(ctx context.Context, projectSlug string, pipelineNumber interface{}) (*GetPipelineByNumberResponse, error) {
	rsp, err := c.GetPipelineByNumber(ctx, projectSlug, pipelineNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineByNumberResponse(rsp)
}

// GetJobArtifactsWithResponse request returning *GetJobArtifactsResponse
func (c *ClientWithResponses) GetJobArtifactsWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*GetJobArtifactsResponse, error) {
	rsp, err := c.GetJobArtifacts(ctx, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetJobArtifactsResponse(rsp)
}

// GetTestsWithResponse request returning *GetTestsResponse
func (c *ClientWithResponses) GetTestsWithResponse(ctx context.Context, projectSlug string, jobNumber interface{}) (*GetTestsResponse, error) {
	rsp, err := c.GetTests(ctx, projectSlug, jobNumber)
	if err != nil {
		return nil, err
	}
	return ParseGetTestsResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id string) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// GetWorkflowByIdWithResponse request returning *GetWorkflowByIdResponse
func (c *ClientWithResponses) GetWorkflowByIdWithResponse(ctx context.Context, id string) (*GetWorkflowByIdResponse, error) {
	rsp, err := c.GetWorkflowById(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowByIdResponse(rsp)
}

// ApprovePendingApprovalJobByIdWithResponse request returning *ApprovePendingApprovalJobByIdResponse
func (c *ClientWithResponses) ApprovePendingApprovalJobByIdWithResponse(ctx context.Context, id string, approvalRequestId string) (*ApprovePendingApprovalJobByIdResponse, error) {
	rsp, err := c.ApprovePendingApprovalJobById(ctx, id, approvalRequestId)
	if err != nil {
		return nil, err
	}
	return ParseApprovePendingApprovalJobByIdResponse(rsp)
}

// CancelWorkflowWithResponse request returning *CancelWorkflowResponse
func (c *ClientWithResponses) CancelWorkflowWithResponse(ctx context.Context, id string) (*CancelWorkflowResponse, error) {
	rsp, err := c.CancelWorkflow(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseCancelWorkflowResponse(rsp)
}

// ListWorkflowJobsWithResponse request returning *ListWorkflowJobsResponse
func (c *ClientWithResponses) ListWorkflowJobsWithResponse(ctx context.Context, id string) (*ListWorkflowJobsResponse, error) {
	rsp, err := c.ListWorkflowJobs(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowJobsResponse(rsp)
}

// RerunWorkflowWithBodyWithResponse request with arbitrary body returning *RerunWorkflowResponse
func (c *ClientWithResponses) RerunWorkflowWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*RerunWorkflowResponse, error) {
	rsp, err := c.RerunWorkflowWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseRerunWorkflowResponse(rsp)
}

func (c *ClientWithResponses) RerunWorkflowWithResponse(ctx context.Context, id string, body RerunWorkflowJSONRequestBody) (*RerunWorkflowResponse, error) {
	rsp, err := c.RerunWorkflow(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseRerunWorkflowResponse(rsp)
}

// ParseListContextsResponse parses an HTTP response from a ListContextsWithResponse call
func ParseListContextsResponse(rsp *http.Response) (*ListContextsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListContextsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The date and time the context was created.
				CreatedAt time.Time `json:"created_at"`

				// The unique ID of the context.
				Id string `json:"id"`

				// The user defined name of the context.
				Name string `json:"name"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateContextResponse parses an HTTP response from a CreateContextWithResponse call
func ParseCreateContextResponse(rsp *http.Response) (*CreateContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The date and time the context was created.
			CreatedAt time.Time `json:"created_at"`

			// The unique ID of the context.
			Id string `json:"id"`

			// The user defined name of the context.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteContextResponse parses an HTTP response from a DeleteContextWithResponse call
func ParseDeleteContextResponse(rsp *http.Response) (*DeleteContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContextResponse parses an HTTP response from a GetContextWithResponse call
func ParseGetContextResponse(rsp *http.Response) (*GetContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The date and time the context was created.
			CreatedAt time.Time `json:"created_at"`

			// The unique ID of the context.
			Id string `json:"id"`

			// The user defined name of the context.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListEnvironmentVariablesFromContextResponse parses an HTTP response from a ListEnvironmentVariablesFromContextWithResponse call
func ParseListEnvironmentVariablesFromContextResponse(rsp *http.Response) (*ListEnvironmentVariablesFromContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListEnvironmentVariablesFromContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// ID of the context (UUID)
				ContextId string `json:"context_id"`

				// The date and time the environment variable was created.
				CreatedAt time.Time `json:"created_at"`

				// The name of the environment variable
				Variable string `json:"variable"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEnvironmentVariableFromContextResponse parses an HTTP response from a DeleteEnvironmentVariableFromContextWithResponse call
func ParseDeleteEnvironmentVariableFromContextResponse(rsp *http.Response) (*DeleteEnvironmentVariableFromContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvironmentVariableFromContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddEnvironmentVariableToContextResponse parses an HTTP response from a AddEnvironmentVariableToContextWithResponse call
func ParseAddEnvironmentVariableToContextResponse(rsp *http.Response) (*AddEnvironmentVariableToContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddEnvironmentVariableToContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// ID of the context (UUID)
			ContextId string `json:"context_id"`

			// The date and time the environment variable was created.
			CreatedAt time.Time `json:"created_at"`

			// The name of the environment variable
			Variable string `json:"variable"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectWorkflowMetricsResponse parses an HTTP response from a GetProjectWorkflowMetricsWithResponse call
func ParseGetProjectWorkflowMetricsResponse(rsp *http.Response) (*GetProjectWorkflowMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectWorkflowMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Workflow summary metrics.
			Items []struct {

				// Metrics relating to a workflow's runs.
				Metrics struct {

					// Metrics relating to the duration of runs for a workflow.
					DurationMetrics struct {

						// The max duration, in seconds, among a group of runs.
						Max int64 `json:"max"`

						// The mean duration, in seconds, among a group of runs.
						Mean int64 `json:"mean"`

						// The median duration, in seconds, among a group of runs.
						Median int64 `json:"median"`

						// The minimum duration, in seconds, among a group of runs.
						Min int64 `json:"min"`

						// The 95th percentile duration, in seconds, among a group of runs.
						P95 int64 `json:"p95"`

						// The standard deviation, in seconds, among a group of runs.
						StandardDeviation float32 `json:"standard_deviation"`
					} `json:"duration_metrics"`

					// The number of failed runs.
					FailedRuns int64 `json:"failed_runs"`

					// The mean time to recovery (mean time between failures and their next success) in seconds.
					Mttr int64 `json:"mttr"`

					// The ratio of successful runs / total runs.
					SuccessRate float32 `json:"success_rate"`

					// The number of successful runs.
					SuccessfulRuns int64 `json:"successful_runs"`

					// The average number of workflow runs per day.
					Throughput float32 `json:"throughput"`

					// The total credits consumed by the workflow in the aggregation window.
					TotalCreditsUsed int64 `json:"total_credits_used"`

					// The total number of runs.
					TotalRuns int64 `json:"total_runs"`
				} `json:"metrics"`

				// The name of the workflow.
				Name string `json:"name"`

				// The end of the aggregation window for workflow metrics.
				WindowEnd time.Time `json:"window_end"`

				// The start of the aggregation window for workflow metrics.
				WindowStart time.Time `json:"window_start"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectWorkflowRunsResponse parses an HTTP response from a GetProjectWorkflowRunsWithResponse call
func ParseGetProjectWorkflowRunsResponse(rsp *http.Response) (*GetProjectWorkflowRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Recent workflow runs.
			Items []struct {

				// The date and time the workflow was created.
				CreatedAt time.Time `json:"created_at"`

				// The number of credits used during execution
				CreditsUsed int64 `json:"credits_used"`

				// The duration in seconds of a run.
				Duration int64 `json:"duration"`

				// The unique ID of the workflow.
				Id string `json:"id"`

				// Workflow status.
				Status string `json:"status"`

				// The date and time the workflow stopped.
				StoppedAt time.Time `json:"stopped_at"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectWorkflowJobMetricsResponse parses an HTTP response from a GetProjectWorkflowJobMetricsWithResponse call
func ParseGetProjectWorkflowJobMetricsResponse(rsp *http.Response) (*GetProjectWorkflowJobMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectWorkflowJobMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Job summary metrics.
			Items []struct {

				// Metrics relating to a workflow job's runs.
				Metrics struct {

					// Metrics relating to the duration of runs for a workflow job.
					DurationMetrics struct {

						// The max duration, in seconds, among a group of runs.
						Max int64 `json:"max"`

						// The mean duration, in seconds, among a group of runs.
						Mean int64 `json:"mean"`

						// The median duration, in seconds, among a group of runs.
						Median int64 `json:"median"`

						// The minimum duration, in seconds, among a group of runs.
						Min int64 `json:"min"`

						// The 95th percentile duration, in seconds, among a group of runs.
						P95 int64 `json:"p95"`

						// The standard deviation, in seconds, among a group of runs.
						StandardDeviation float32 `json:"standard_deviation"`
					} `json:"duration_metrics"`

					// The number of failed runs.
					FailedRuns int64 `json:"failed_runs"`

					// The ratio of successful runs / total runs.
					SuccessRate float32 `json:"success_rate"`

					// The number of successful runs.
					SuccessfulRuns int64 `json:"successful_runs"`

					// The average number of job runs per day.
					Throughput float32 `json:"throughput"`

					// The total credits consumed by the job in the aggregation window.
					TotalCreditsUsed int64 `json:"total_credits_used"`

					// The total number of runs.
					TotalRuns int64 `json:"total_runs"`
				} `json:"metrics"`

				// The name of the job.
				Name string `json:"name"`

				// The end of the aggregation window for job metrics.
				WindowEnd time.Time `json:"window_end"`

				// The start of the aggregation window for job metrics.
				WindowStart time.Time `json:"window_start"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectJobRunsResponse parses an HTTP response from a GetProjectJobRunsWithResponse call
func ParseGetProjectJobRunsResponse(rsp *http.Response) (*GetProjectJobRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectJobRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Recent job runs.
			Items []struct {

				// The number of credits used during execution
				CreditsUsed int64 `json:"credits_used"`

				// The unique ID of the job.
				Id string `json:"id"`

				// The date and time the job started.
				StartedAt time.Time `json:"started_at"`

				// Job status.
				Status string `json:"status"`

				// The time when the job stopped.
				StoppedAt time.Time `json:"stopped_at"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The unique ID of the user.
			Id string `json:"id"`

			// The login information for the user on the VCS.
			Login string `json:"login"`

			// The name of the user.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCollaborationsResponse parses an HTTP response from a GetCollaborationsWithResponse call
func ParseGetCollaborationsResponse(rsp *http.Response) (*GetCollaborationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCollaborationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// URL to the user's avatar on the VCS
			AvatarUrl string `json:"avatar_url"`

			// The name of the organization
			Name string `json:"name"`

			// The VCS provider
			VcsType string `json:"vcs-type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPipelinesResponse parses an HTTP response from a ListPipelinesWithResponse call
func ParseListPipelinesResponse(rsp *http.Response) (*ListPipelinesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The date and time the pipeline was created.
				CreatedAt time.Time `json:"created_at"`

				// A sequence of errors that have occurred within the pipeline.
				Errors []struct {

					// A human-readable error message.
					Message string `json:"message"`

					// The type of error.
					Type string `json:"type"`
				} `json:"errors"`

				// The unique ID of the pipeline.
				Id string `json:"id"`

				// The number of the pipeline.
				Number int64 `json:"number"`

				// The project-slug for the pipeline.
				ProjectSlug string `json:"project_slug"`

				// The current state of the pipeline.
				State string `json:"state"`

				// A summary of the trigger.
				Trigger struct {

					// The user who triggered the Pipeline.
					Actor struct {

						// URL to the user's avatar on the VCS
						AvatarUrl string `json:"avatar_url"`

						// The login information for the user on the VCS.
						Login string `json:"login"`
					} `json:"actor"`

					// The date and time the trigger was received.
					ReceivedAt time.Time `json:"received_at"`

					// The type of trigger.
					Type string `json:"type"`
				} `json:"trigger"`

				// The date and time the pipeline was last updated.
				UpdatedAt *time.Time `json:"updated_at,omitempty"`

				// VCS information for the pipeline.
				Vcs *struct {

					// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
					Branch *string `json:"branch,omitempty"`

					// The latest commit in the pipeline.
					Commit *struct {

						// The body of the commit message.
						Body string `json:"body"`

						// The subject of the commit message.
						Subject string `json:"subject"`
					} `json:"commit,omitempty"`

					// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
					OriginRepositoryUrl string `json:"origin_repository_url"`

					// Name of the VCS provider (e.g. GitHub, Bitbucket).
					ProviderName string `json:"provider_name"`

					// The code revision the pipeline ran.
					Revision string `json:"revision"`

					// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
					Tag *string `json:"tag,omitempty"`

					// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
					TargetRepositoryUrl string `json:"target_repository_url"`
				} `json:"vcs,omitempty"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineByIdResponse parses an HTTP response from a GetPipelineByIdWithResponse call
func ParseGetPipelineByIdResponse(rsp *http.Response) (*GetPipelineByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The date and time the pipeline was created.
			CreatedAt time.Time `json:"created_at"`

			// A sequence of errors that have occurred within the pipeline.
			Errors []struct {

				// A human-readable error message.
				Message string `json:"message"`

				// The type of error.
				Type string `json:"type"`
			} `json:"errors"`

			// The unique ID of the pipeline.
			Id string `json:"id"`

			// The number of the pipeline.
			Number int64 `json:"number"`

			// The project-slug for the pipeline.
			ProjectSlug string `json:"project_slug"`

			// The current state of the pipeline.
			State string `json:"state"`

			// A summary of the trigger.
			Trigger struct {

				// The user who triggered the Pipeline.
				Actor struct {

					// URL to the user's avatar on the VCS
					AvatarUrl string `json:"avatar_url"`

					// The login information for the user on the VCS.
					Login string `json:"login"`
				} `json:"actor"`

				// The date and time the trigger was received.
				ReceivedAt time.Time `json:"received_at"`

				// The type of trigger.
				Type string `json:"type"`
			} `json:"trigger"`

			// The date and time the pipeline was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// VCS information for the pipeline.
			Vcs *struct {

				// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Branch *string `json:"branch,omitempty"`

				// The latest commit in the pipeline.
				Commit *struct {

					// The body of the commit message.
					Body string `json:"body"`

					// The subject of the commit message.
					Subject string `json:"subject"`
				} `json:"commit,omitempty"`

				// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
				OriginRepositoryUrl string `json:"origin_repository_url"`

				// Name of the VCS provider (e.g. GitHub, Bitbucket).
				ProviderName string `json:"provider_name"`

				// The code revision the pipeline ran.
				Revision string `json:"revision"`

				// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Tag *string `json:"tag,omitempty"`

				// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
				TargetRepositoryUrl string `json:"target_repository_url"`
			} `json:"vcs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineConfigByIdResponse parses an HTTP response from a GetPipelineConfigByIdWithResponse call
func ParseGetPipelineConfigByIdResponse(rsp *http.Response) (*GetPipelineConfigByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineConfigByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The compiled configuration for the pipeline, after all orb expansion has been performed. If there were errors processing the pipeline's configuration, then this field may be empty.
			Compiled string `json:"compiled"`

			// The source configuration for the pipeline, before any config compilation has been performed. If there is no config, then this field will be empty.
			Source string `json:"source"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListWorkflowsByPipelineIdResponse parses an HTTP response from a ListWorkflowsByPipelineIdWithResponse call
func ParseListWorkflowsByPipelineIdResponse(rsp *http.Response) (*ListWorkflowsByPipelineIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowsByPipelineIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// A list of workflows.
			Items []struct {
				CanceledBy *string `json:"canceled_by,omitempty"`

				// The date and time the workflow was created.
				CreatedAt time.Time `json:"created_at"`
				ErroredBy *string   `json:"errored_by,omitempty"`

				// The unique ID of the workflow.
				Id string `json:"id"`

				// The name of the workflow.
				Name string `json:"name"`

				// The ID of the pipeline this workflow belongs to.
				PipelineId string `json:"pipeline_id"`

				// The number of the pipeline this workflow belongs to.
				PipelineNumber int64 `json:"pipeline_number"`

				// The project-slug for the pipeline this workflow belongs to.
				ProjectSlug string `json:"project_slug"`
				StartedBy   string `json:"started_by"`

				// The current status of the workflow.
				Status string `json:"status"`

				// The date and time the workflow stopped.
				StoppedAt time.Time `json:"stopped_at"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectBySlugResponse parses an HTTP response from a GetProjectBySlugWithResponse call
func ParseGetProjectBySlugResponse(rsp *http.Response) (*GetProjectBySlugResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectBySlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The name of the project
			Name string `json:"name"`

			// The name of the organization the project belongs to
			OrganizationName string `json:"organization_name"`

			// Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
			Slug string `json:"slug"`

			// Information about the VCS that hosts the project source code.
			VcsInfo struct {
				DefaultBranch string `json:"default_branch"`

				// The VCS provider
				Provider string `json:"provider"`

				// URL to the repository hosting the project's code
				VcsUrl string `json:"vcs_url"`
			} `json:"vcs_info"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCheckoutKeysResponse parses an HTTP response from a ListCheckoutKeysWithResponse call
func ParseListCheckoutKeysResponse(rsp *http.Response) (*ListCheckoutKeysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCheckoutKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The date and time the checkout key was created.
				CreatedAt time.Time `json:"created-at"`

				// An SSH key fingerprint.
				Fingerprint string `json:"fingerprint"`

				// A boolean value that indicates if this key is preferred.
				Preferred bool `json:"preferred"`

				// A public SSH key.
				PublicKey string `json:"public-key"`

				// The type of checkout key. This may be either `deploy-key` or `github-user-key`.
				Type string `json:"type"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCheckoutKeyResponse parses an HTTP response from a CreateCheckoutKeyWithResponse call
func ParseCreateCheckoutKeyResponse(rsp *http.Response) (*CreateCheckoutKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCheckoutKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {

			// The date and time the checkout key was created.
			CreatedAt time.Time `json:"created-at"`

			// An SSH key fingerprint.
			Fingerprint string `json:"fingerprint"`

			// A boolean value that indicates if this key is preferred.
			Preferred bool `json:"preferred"`

			// A public SSH key.
			PublicKey string `json:"public-key"`

			// The type of checkout key. This may be either `deploy-key` or `github-user-key`.
			Type string `json:"type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCheckoutKeyResponse parses an HTTP response from a DeleteCheckoutKeyWithResponse call
func ParseDeleteCheckoutKeyResponse(rsp *http.Response) (*DeleteCheckoutKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCheckoutKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCheckoutKeyResponse parses an HTTP response from a GetCheckoutKeyWithResponse call
func ParseGetCheckoutKeyResponse(rsp *http.Response) (*GetCheckoutKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCheckoutKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The date and time the checkout key was created.
			CreatedAt time.Time `json:"created-at"`

			// An SSH key fingerprint.
			Fingerprint string `json:"fingerprint"`

			// A boolean value that indicates if this key is preferred.
			Preferred bool `json:"preferred"`

			// A public SSH key.
			PublicKey string `json:"public-key"`

			// The type of checkout key. This may be either `deploy-key` or `github-user-key`.
			Type string `json:"type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListEnvVarsResponse parses an HTTP response from a ListEnvVarsWithResponse call
func ParseListEnvVarsResponse(rsp *http.Response) (*ListEnvVarsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListEnvVarsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The name of the environment variable.
				Name string `json:"name"`

				// The value of the environment variable.
				Value string `json:"value"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEnvVarResponse parses an HTTP response from a CreateEnvVarWithResponse call
func ParseCreateEnvVarResponse(rsp *http.Response) (*CreateEnvVarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvVarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {

			// The name of the environment variable.
			Name string `json:"name"`

			// The value of the environment variable.
			Value string `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEnvVarResponse parses an HTTP response from a DeleteEnvVarWithResponse call
func ParseDeleteEnvVarResponse(rsp *http.Response) (*DeleteEnvVarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvVarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvVarResponse parses an HTTP response from a GetEnvVarWithResponse call
func ParseGetEnvVarResponse(rsp *http.Response) (*GetEnvVarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEnvVarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The name of the environment variable.
			Name string `json:"name"`

			// The value of the environment variable.
			Value string `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJobDetailsResponse parses an HTTP response from a GetJobDetailsWithResponse call
func ParseGetJobDetailsResponse(rsp *http.Response) (*GetJobDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetJobDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// List of contexts used by the job.
			Contexts []struct {

				// The name of the context.
				Name string `json:"name"`
			} `json:"contexts"`

			// The time when the job was created.
			CreatedAt time.Time `json:"created_at"`

			// Duration of a job in milliseconds.
			Duration int64 `json:"duration"`

			// Information about executor used for a job.
			Executor struct {

				// Resource class name.
				ResourceClass string `json:"resource_class"`

				// Executor type.
				Type string `json:"type"`
			} `json:"executor"`

			// Info about the latest workflow the job was a part of.
			LatestWorkflow struct {

				// The unique ID of the workflow.
				Id string `json:"id"`

				// The name of the workflow.
				Name string `json:"name"`
			} `json:"latest_workflow"`

			// Messages from CircleCI execution platform.
			Messages []struct {

				// Information describing message.
				Message string `json:"message"`

				// Value describing the reason for message to be added to the job.
				Reason *string `json:"reason,omitempty"`

				// Message type.
				Type string `json:"type"`
			} `json:"messages"`

			// The name of the job.
			Name string `json:"name"`

			// The number of the job.
			Number int64 `json:"number"`

			// Information about an organization.
			Organization struct {

				// The name of the organization.
				Name string `json:"name"`
			} `json:"organization"`

			// Info about parallels runs and their status.
			ParallelRuns []struct {

				// Index of the parallel run.
				Index int64 `json:"index"`

				// Status of the parallel run.
				Status string `json:"status"`
			} `json:"parallel_runs"`

			// A number of parallel runs the job has.
			Parallelism int64 `json:"parallelism"`

			// Info about a pipeline the job is a part of.
			Pipeline struct {

				// The unique ID of the pipeline.
				Id string `json:"id"`
			} `json:"pipeline"`

			// Information about a project.
			Project struct {

				// URL to the repository hosting the project's code
				ExternalUrl string `json:"external_url"`

				// The name of the project
				Name string `json:"name"`

				// Project slug in the form `vcs-slug/org-name/repo-name`. The `/` characters may be URL-escaped.
				Slug string `json:"slug"`
			} `json:"project"`

			// The time when the job was placed in a queue.
			QueuedAt time.Time `json:"queued_at"`

			// The date and time the job started.
			StartedAt time.Time `json:"started_at"`

			// The current status of the job.
			Status interface{} `json:"status"`

			// The time when the job stopped.
			StoppedAt *time.Time `json:"stopped_at,omitempty"`

			// URL of the job in CircleCI Web UI.
			WebUrl string `json:"web_url"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCancelJobResponse parses an HTTP response from a CancelJobWithResponse call
func ParseCancelJobResponse(rsp *http.Response) (*CancelJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CancelJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPipelinesForProjectResponse parses an HTTP response from a ListPipelinesForProjectWithResponse call
func ParseListPipelinesForProjectResponse(rsp *http.Response) (*ListPipelinesForProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPipelinesForProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The date and time the pipeline was created.
				CreatedAt time.Time `json:"created_at"`

				// A sequence of errors that have occurred within the pipeline.
				Errors []struct {

					// A human-readable error message.
					Message string `json:"message"`

					// The type of error.
					Type string `json:"type"`
				} `json:"errors"`

				// The unique ID of the pipeline.
				Id string `json:"id"`

				// The number of the pipeline.
				Number int64 `json:"number"`

				// The project-slug for the pipeline.
				ProjectSlug string `json:"project_slug"`

				// The current state of the pipeline.
				State string `json:"state"`

				// A summary of the trigger.
				Trigger struct {

					// The user who triggered the Pipeline.
					Actor struct {

						// URL to the user's avatar on the VCS
						AvatarUrl string `json:"avatar_url"`

						// The login information for the user on the VCS.
						Login string `json:"login"`
					} `json:"actor"`

					// The date and time the trigger was received.
					ReceivedAt time.Time `json:"received_at"`

					// The type of trigger.
					Type string `json:"type"`
				} `json:"trigger"`

				// The date and time the pipeline was last updated.
				UpdatedAt *time.Time `json:"updated_at,omitempty"`

				// VCS information for the pipeline.
				Vcs *struct {

					// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
					Branch *string `json:"branch,omitempty"`

					// The latest commit in the pipeline.
					Commit *struct {

						// The body of the commit message.
						Body string `json:"body"`

						// The subject of the commit message.
						Subject string `json:"subject"`
					} `json:"commit,omitempty"`

					// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
					OriginRepositoryUrl string `json:"origin_repository_url"`

					// Name of the VCS provider (e.g. GitHub, Bitbucket).
					ProviderName string `json:"provider_name"`

					// The code revision the pipeline ran.
					Revision string `json:"revision"`

					// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
					Tag *string `json:"tag,omitempty"`

					// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
					TargetRepositoryUrl string `json:"target_repository_url"`
				} `json:"vcs,omitempty"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTriggerPipelineResponse parses an HTTP response from a TriggerPipelineWithResponse call
func ParseTriggerPipelineResponse(rsp *http.Response) (*TriggerPipelineResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &TriggerPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {

			// The date and time the pipeline was created.
			CreatedAt time.Time `json:"created_at"`

			// The unique ID of the pipeline.
			Id string `json:"id"`

			// The number of the pipeline.
			Number int64 `json:"number"`

			// The current state of the pipeline.
			State string `json:"state"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMyPipelinesResponse parses an HTTP response from a ListMyPipelinesWithResponse call
func ParseListMyPipelinesResponse(rsp *http.Response) (*ListMyPipelinesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListMyPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The date and time the pipeline was created.
				CreatedAt time.Time `json:"created_at"`

				// A sequence of errors that have occurred within the pipeline.
				Errors []struct {

					// A human-readable error message.
					Message string `json:"message"`

					// The type of error.
					Type string `json:"type"`
				} `json:"errors"`

				// The unique ID of the pipeline.
				Id string `json:"id"`

				// The number of the pipeline.
				Number int64 `json:"number"`

				// The project-slug for the pipeline.
				ProjectSlug string `json:"project_slug"`

				// The current state of the pipeline.
				State string `json:"state"`

				// A summary of the trigger.
				Trigger struct {

					// The user who triggered the Pipeline.
					Actor struct {

						// URL to the user's avatar on the VCS
						AvatarUrl string `json:"avatar_url"`

						// The login information for the user on the VCS.
						Login string `json:"login"`
					} `json:"actor"`

					// The date and time the trigger was received.
					ReceivedAt time.Time `json:"received_at"`

					// The type of trigger.
					Type string `json:"type"`
				} `json:"trigger"`

				// The date and time the pipeline was last updated.
				UpdatedAt *time.Time `json:"updated_at,omitempty"`

				// VCS information for the pipeline.
				Vcs *struct {

					// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
					Branch *string `json:"branch,omitempty"`

					// The latest commit in the pipeline.
					Commit *struct {

						// The body of the commit message.
						Body string `json:"body"`

						// The subject of the commit message.
						Subject string `json:"subject"`
					} `json:"commit,omitempty"`

					// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
					OriginRepositoryUrl string `json:"origin_repository_url"`

					// Name of the VCS provider (e.g. GitHub, Bitbucket).
					ProviderName string `json:"provider_name"`

					// The code revision the pipeline ran.
					Revision string `json:"revision"`

					// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
					Tag *string `json:"tag,omitempty"`

					// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
					TargetRepositoryUrl string `json:"target_repository_url"`
				} `json:"vcs,omitempty"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineByNumberResponse parses an HTTP response from a GetPipelineByNumberWithResponse call
func ParseGetPipelineByNumberResponse(rsp *http.Response) (*GetPipelineByNumberResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineByNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The date and time the pipeline was created.
			CreatedAt time.Time `json:"created_at"`

			// A sequence of errors that have occurred within the pipeline.
			Errors []struct {

				// A human-readable error message.
				Message string `json:"message"`

				// The type of error.
				Type string `json:"type"`
			} `json:"errors"`

			// The unique ID of the pipeline.
			Id string `json:"id"`

			// The number of the pipeline.
			Number int64 `json:"number"`

			// The project-slug for the pipeline.
			ProjectSlug string `json:"project_slug"`

			// The current state of the pipeline.
			State string `json:"state"`

			// A summary of the trigger.
			Trigger struct {

				// The user who triggered the Pipeline.
				Actor struct {

					// URL to the user's avatar on the VCS
					AvatarUrl string `json:"avatar_url"`

					// The login information for the user on the VCS.
					Login string `json:"login"`
				} `json:"actor"`

				// The date and time the trigger was received.
				ReceivedAt time.Time `json:"received_at"`

				// The type of trigger.
				Type string `json:"type"`
			} `json:"trigger"`

			// The date and time the pipeline was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// VCS information for the pipeline.
			Vcs *struct {

				// The branch where the pipeline ran. The HEAD commit on this branch was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Branch *string `json:"branch,omitempty"`

				// The latest commit in the pipeline.
				Commit *struct {

					// The body of the commit message.
					Body string `json:"body"`

					// The subject of the commit message.
					Subject string `json:"subject"`
				} `json:"commit,omitempty"`

				// URL for the repository where the trigger originated. For fork-PR pipelines, this is the URL to the fork. For other pipelines the `origin_` and `target_repository_url`s will be the same.
				OriginRepositoryUrl string `json:"origin_repository_url"`

				// Name of the VCS provider (e.g. GitHub, Bitbucket).
				ProviderName string `json:"provider_name"`

				// The code revision the pipeline ran.
				Revision string `json:"revision"`

				// The tag used by the pipeline. The commit that this tag points to was used for the pipeline. Note that `branch` and `tag` are mutually exclusive.
				Tag *string `json:"tag,omitempty"`

				// URL for the repository the trigger targets (i.e. the repository where the PR will be merged). For fork-PR pipelines, this is the URL to the parent repo. For other pipelines, the `origin_` and `target_repository_url`s will be the same.
				TargetRepositoryUrl string `json:"target_repository_url"`
			} `json:"vcs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJobArtifactsResponse parses an HTTP response from a GetJobArtifactsWithResponse call
func ParseGetJobArtifactsResponse(rsp *http.Response) (*GetJobArtifactsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetJobArtifactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The index of the node that stored the artifact.
				NodeIndex int64 `json:"node_index"`

				// The artifact path.
				Path string `json:"path"`

				// The URL to download the artifact contents.
				Url string `json:"url"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTestsResponse parses an HTTP response from a GetTestsWithResponse call
func ParseGetTestsResponse(rsp *http.Response) (*GetTestsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The programmatic location of the test.
				Classname string `json:"classname"`

				// The file in which the test is defined.
				File string `json:"file"`

				// The failure message associated with the test.
				Message string `json:"message"`

				// The name of the test.
				Name string `json:"name"`

				// Indication of whether the test succeeded.
				Result string `json:"result"`

				// The time it took to run the test in seconds
				RunTime float64 `json:"run_time"`

				// The program that generated the test results
				Source string `json:"source"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// The unique ID of the user.
			Id string `json:"id"`

			// The login information for the user on the VCS.
			Login string `json:"login"`

			// The name of the user.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWorkflowByIdResponse parses an HTTP response from a GetWorkflowByIdWithResponse call
func ParseGetWorkflowByIdResponse(rsp *http.Response) (*GetWorkflowByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CanceledBy *string `json:"canceled_by,omitempty"`

			// The date and time the workflow was created.
			CreatedAt time.Time `json:"created_at"`
			ErroredBy *string   `json:"errored_by,omitempty"`

			// The unique ID of the workflow.
			Id string `json:"id"`

			// The name of the workflow.
			Name string `json:"name"`

			// The ID of the pipeline this workflow belongs to.
			PipelineId string `json:"pipeline_id"`

			// The number of the pipeline this workflow belongs to.
			PipelineNumber int64 `json:"pipeline_number"`

			// The project-slug for the pipeline this workflow belongs to.
			ProjectSlug string `json:"project_slug"`
			StartedBy   string `json:"started_by"`

			// The current status of the workflow.
			Status string `json:"status"`

			// The date and time the workflow stopped.
			StoppedAt time.Time `json:"stopped_at"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseApprovePendingApprovalJobByIdResponse parses an HTTP response from a ApprovePendingApprovalJobByIdWithResponse call
func ParseApprovePendingApprovalJobByIdResponse(rsp *http.Response) (*ApprovePendingApprovalJobByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ApprovePendingApprovalJobByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCancelWorkflowResponse parses an HTTP response from a CancelWorkflowWithResponse call
func ParseCancelWorkflowResponse(rsp *http.Response) (*CancelWorkflowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CancelWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListWorkflowJobsResponse parses an HTTP response from a ListWorkflowJobsWithResponse call
func ParseListWorkflowJobsResponse(rsp *http.Response) (*ListWorkflowJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []struct {

				// The unique ID of the job.
				ApprovalRequestId *string `json:"approval_request_id,omitempty"`

				// The unique ID of the user.
				ApprovedBy *string `json:"approved_by,omitempty"`

				// The unique ID of the user.
				CanceledBy *string `json:"canceled_by,omitempty"`

				// A sequence of the unique job IDs for the jobs that this job depends upon in the workflow.
				Dependencies []string `json:"dependencies"`

				// The unique ID of the job.
				Id string `json:"id"`

				// The number of the job.
				JobNumber *int64 `json:"job_number,omitempty"`

				// The name of the job.
				Name string `json:"name"`

				// The project-slug for the job.
				ProjectSlug string `json:"project_slug"`

				// The date and time the job started.
				StartedAt time.Time `json:"started_at"`

				// The current status of the job.
				Status interface{} `json:"status"`

				// The time when the job stopped.
				StoppedAt *time.Time `json:"stopped_at,omitempty"`

				// The type of job.
				Type string `json:"type"`
			} `json:"items"`

			// A token to pass as a `page-token` query parameter to return the next page of results.
			NextPageToken string `json:"next_page_token"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRerunWorkflowResponse parses an HTTP response from a RerunWorkflowWithResponse call
func ParseRerunWorkflowResponse(rsp *http.Response) (*RerunWorkflowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RerunWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {

			// A human-readable message
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json"):
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

